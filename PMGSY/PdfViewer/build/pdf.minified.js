if (typeof PDFJS === "undefined") { (typeof window !== "undefined" ? window : this).PDFJS = {} } PDFJS.version = "1.0.473"; PDFJS.build = "1694cd8"; (function () { "use strict"; "use strict"; function l(e) { if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) { console.log("Info: " + e) } } function c(e) { if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) { console.log("Warning: " + e) } } function h(e) { if (arguments.length > 1) { var t = ["Error:"]; t.push.apply(t, arguments); console.log.apply(console, t); e = [].join.call(arguments, " ") } else { console.log("Error: " + e) } console.log(p()); m.notify(v.unknown); throw new Error(e) } function p() { try { throw new Error } catch (e) { return e.stack ? e.stack.split("\n").slice(2).join("\n") : "" } } function d(e, t) { if (!e) { h(t) } } function g(e, t) { if (!t) { return e } if (/^[a-z][a-z0-9+\-.]*:/i.test(t)) { return t } var n; if (t.charAt(0) == "/") { n = e.indexOf("://"); if (t.charAt(1) === "/") { ++n } else { n = e.indexOf("/", n + 3) } return e.substring(0, n) + t } else { var r = e.length; n = e.lastIndexOf("#"); r = n >= 0 ? n : r; n = e.lastIndexOf("?", r); r = n >= 0 ? n : r; var i = e.lastIndexOf("/", r); return e.substring(0, i + 1) + t } } function y(e, t) { if (!e) { return false } var n = /^[a-z][a-z0-9+\-.]*(?=:)/i.exec(e); if (!n) { return t } n = n[0].toLowerCase(); switch (n) { case "http": case "https": case "ftp": case "mailto": return true; default: return false } } function b(e, t, n) { Object.defineProperty(e, t, { value: n, enumerable: true, configurable: true, writable: false }); return n } function L(e) { var t = e.length; var n = 8192; if (t < n) { return String.fromCharCode.apply(null, e) } var r = []; for (var i = 0; i < t; i += n) { var s = Math.min(i + n, t); var o = e.subarray(i, s); r.push(String.fromCharCode.apply(null, o)) } return r.join("") } function A(e) { var t = e.length; var n = []; for (var r = 0; r < t; ++r) { n[r] = e.charCodeAt(r) } return n } function O(e) { var t = e.length; var n = new Uint8Array(t); for (var r = 0; r < t; ++r) { n[r] = e.charCodeAt(r) & 255 } return n } function M(e) { return String.fromCharCode(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255) } function _(e) { var t = 1, n = 0; while (e > t) { t <<= 1; n++ } return n } function D(e, t) { return e[t] << 24 >> 24 } function P(e, t) { return e[t] << 8 | e[t + 1] } function H(e, t) { return (e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]) >>> 0 } function B() { var e = new Uint8Array(2); e[0] = 1; var t = new Uint16Array(e.buffer); return t[0] === 1 } function j() { var e = document.createElement("canvas"); e.width = e.height = 1; var t = e.getContext("2d"); var n = t.createImageData(1, 1); return typeof n.data.buffer !== "undefined" } function z(e) { var t, n = e.length, r = []; if (e[0] === "þ" && e[1] === "ÿ") { for (t = 2; t < n; t += 2) { r.push(String.fromCharCode(e.charCodeAt(t) << 8 | e.charCodeAt(t + 1))) } } else { for (t = 0; t < n; ++t) { var i = U[e.charCodeAt(t)]; r.push(i ? String.fromCharCode(i) : e.charAt(t)) } } return r.join("") } function W(e) { return decodeURIComponent(escape(e)) } function X(e) { for (var t in e) { return false } return true } function V(e) { return typeof e == "boolean" } function $(e) { return typeof e === "number" && (e | 0) === e } function J(e) { return typeof e === "number" } function K(e) { return typeof e === "string" } function Q(e) { return e === null } function G(e) { return e instanceof Name } function Y(e, t) { return e instanceof Cmd && (t === undefined || e.cmd === t) } function Z(e, t) { if (!(e instanceof Dict)) { return false } if (!t) { return true } var n = e.get("Type"); return G(n) && n.name === t } function et(e) { return e instanceof Array } function tt(e) { return typeof e === "object" && e !== null && e.getBytes !== undefined } function nt(e) { return typeof e === "object" && e !== null && e.byteLength !== undefined } function rt(e) { return e instanceof Ref } function it() { var e = {}; e.promise = new Promise(function (t, n) { e.resolve = t; e.reject = n }); return e } function ot(e, t) { this.name = e; this.comObj = t; this.callbackIndex = 1; this.postMessageTransfers = true; var n = this.callbacksCapabilities = {}; var r = this.actionHandler = {}; r["console_log"] = [function (t) { console.log.apply(console, t) }]; r["console_error"] = [function (t) { console.error.apply(console, t) }]; r["_unsupported_feature"] = [function (t) { m.notify(t) }]; t.onmessage = function (i) { var s = i.data; if (s.isReply) { var o = s.callbackId; if (s.callbackId in n) { var u = n[o]; delete n[o]; if ("error" in s) { u.reject(s.error) } else { u.resolve(s.data) } } else { h("Cannot resolve callback " + o) } } else if (s.action in r) { var a = r[s.action]; if (s.callbackId) { Promise.resolve().then(function () { return a[0].call(a[1], s.data) }).then(function (e) { t.postMessage({ isReply: true, callbackId: s.callbackId, data: e }) }, function (e) { t.postMessage({ isReply: true, callbackId: s.callbackId, error: e }) }) } else { a[0].call(a[1], s.data) } } else { h("Unknown action from worker: " + s.action) } } } function ut(e, t, n) { var r = new Image; r.onload = function () { n.resolve(e, r) }; r.onerror = function () { n.resolve(e, null); c("Error during JPEG image loading") }; r.src = t } function yt(e, t) { var n = document.createElement("canvas"); n.width = e; n.height = t; return n } function bt(e) { if (!e.mozCurrentTransform) { e._scaleX = e._scaleX || 1; e._scaleY = e._scaleY || 1; e._originalSave = e.save; e._originalRestore = e.restore; e._originalRotate = e.rotate; e._originalScale = e.scale; e._originalTranslate = e.translate; e._originalTransform = e.transform; e._originalSetTransform = e.setTransform; e._transformMatrix = [e._scaleX, 0, 0, e._scaleY, 0, 0]; e._transformStack = []; Object.defineProperty(e, "mozCurrentTransform", { get: function () { return this._transformMatrix } }); Object.defineProperty(e, "mozCurrentTransformInverse", { get: function () { var t = this._transformMatrix; var n = t[0], r = t[1], i = t[2], s = t[3], o = t[4], u = t[5]; var a = n * s - r * i; var f = r * i - n * s; return [s / a, r / f, i / f, n / a, (s * o - i * u) / f, (r * o - n * u) / a] } }); e.save = function () { var t = this._transformMatrix; this._transformStack.push(t); this._transformMatrix = t.slice(0, 6); this._originalSave() }; e.restore = function () { var t = this._transformStack.pop(); if (t) { this._transformMatrix = t; this._originalRestore() } }; e.translate = function (t, n) { var r = this._transformMatrix; r[4] = r[0] * t + r[2] * n + r[4]; r[5] = r[1] * t + r[3] * n + r[5]; this._originalTranslate(t, n) }; e.scale = function (t, n) { var r = this._transformMatrix; r[0] = r[0] * t; r[1] = r[1] * t; r[2] = r[2] * n; r[3] = r[3] * n; this._originalScale(t, n) }; e.transform = function (n, r, i, s, o, u) { var a = this._transformMatrix; this._transformMatrix = [a[0] * n + a[2] * r, a[1] * n + a[3] * r, a[0] * i + a[2] * s, a[1] * i + a[3] * s, a[0] * o + a[2] * u + a[4], a[1] * o + a[3] * u + a[5]]; e._originalTransform(n, r, i, s, o, u) }; e.setTransform = function (n, r, i, s, o, u) { this._transformMatrix = [n, r, i, s, o, u]; e._originalSetTransform(n, r, i, s, o, u) }; e.rotate = function (t) { var n = Math.cos(t); var r = Math.sin(t); var i = this._transformMatrix; this._transformMatrix = [i[0] * n + i[2] * r, i[1] * n + i[3] * r, i[0] * -r + i[2] * n, i[1] * -r + i[3] * n, i[4], i[5]]; this._originalRotate(t) } } } function Et(e) { var t = 1e3; var n = e.width, r = e.height; var i, s, o, u = n + 1; var a = new Uint8Array(u * (r + 1)); var f = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]); var l = n + 7 & ~7, c = e.data; var h = new Uint8Array(l * r), p = 0, d; for (i = 0, d = c.length; i < d; i++) { var v = 128, m = c[i]; while (v > 0) { h[p++] = m & v ? 0 : 255; v >>= 1 } } var g = 0; p = 0; if (h[p] !== 0) { a[0] = 1; ++g } for (s = 1; s < n; s++) { if (h[p] !== h[p + 1]) { a[s] = h[p] ? 2 : 1; ++g } p++ } if (h[p] !== 0) { a[s] = 2; ++g } for (i = 1; i < r; i++) { p = i * l; o = i * u; if (h[p - l] !== h[p]) { a[o] = h[p] ? 1 : 8; ++g } var y = (h[p] ? 4 : 0) + (h[p - l] ? 8 : 0); for (s = 1; s < n; s++) { y = (y >> 2) + (h[p + 1] ? 4 : 0) + (h[p - l + 1] ? 8 : 0); if (f[y]) { a[o + s] = f[y]; ++g } p++ } if (h[p - l] !== h[p]) { a[o + s] = h[p] ? 2 : 4; ++g } if (g > t) { return null } } p = l * (r - 1); o = i * u; if (h[p] !== 0) { a[o] = 8; ++g } for (s = 1; s < n; s++) { if (h[p] !== h[p + 1]) { a[o + s] = h[p] ? 4 : 8; ++g } p++ } if (h[p] !== 0) { a[o + s] = 4; ++g } if (g > t) { return null } var b = new Int32Array([0, u, -1, 0, -u, 0, 0, 0, 1]); var w = []; for (i = 0; g && i <= r; i++) { var E = i * u; var S = E + n; while (E < S && !a[E]) { E++ } if (E === S) { continue } var x = [E % u, i]; var T = a[E], N = E, C; do { var k = b[T]; do { E += k } while (!a[E]); C = a[E]; if (C !== 5 && C !== 10) { T = C; a[E] = 0 } else { T = C & 51 * T >> 4; a[E] &= T >> 2 | T << 2 } x.push(E % u); x.push(E / u | 0); --g } while (N !== E); w.push(x); --i } var L = function (e) { e.save(); e.scale(1 / n, -1 / r); e.translate(0, -r); e.beginPath(); for (var t = 0, i = w.length; t < i; t++) { var s = w[t]; e.moveTo(s[0], s[1]); for (var o = 2, u = s.length; o < u; o += 2) { e.lineTo(s[o], s[o + 1]) } } e.fill(); e.beginPath(); e.restore() }; return L } function kt(e) { var t = Nt[e[0]]; if (!t) { h("Unknown IR type: " + e[0]) } return t.fromIR(e) } var t = typeof window === "undefined" ? this : window; var n = typeof window == "undefined"; var r = [.001, 0, 0, .001, 0, 0]; var i = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }; var s = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }; var o = { WIDGET: 1, TEXT: 2, LINK: 3 }; var u = { UNKNOWN: 0, FLATE: 1, LZW: 2, DCT: 3, JPX: 4, JBIG: 5, A85: 6, AHX: 7, CCF: 8, RL: 9 }; var a = { UNKNOWN: 0, TYPE1: 1, TYPE1C: 2, CIDFONTTYPE0: 3, CIDFONTTYPE0C: 4, TRUETYPE: 5, CIDFONTTYPE2: 6, TYPE3: 7, OPENTYPE: 8, TYPE0: 9, MMTYPE1: 10 }; if (!t.PDFJS) { t.PDFJS = {} } t.PDFJS.pdfBug = false; PDFJS.VERBOSITY_LEVELS = { errors: 0, warnings: 1, infos: 5 }; var f = PDFJS.OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotations: 78, endAnnotations: 79, beginAnnotation: 80, endAnnotation: 81, paintJpegXObject: 82, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; var v = PDFJS.UNSUPPORTED_FEATURES = { unknown: "unknown", forms: "forms", javaScript: "javaScript", smask: "smask", shadingPattern: "shadingPattern", font: "font" }; var m = PDFJS.UnsupportedManager = function () { var t = []; return { listen: function (e) { t.push(e) }, notify: function (e) { c('Unsupported feature "' + e + '"'); for (var n = 0, r = t.length; n < r; n++) { t[n](e) } } } }(); PDFJS.isValidUrl = y; var w = PDFJS.PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; var E = function () { function t(e, t) { this.name = "PasswordException"; this.message = e; this.code = t } t.prototype = new Error; t.constructor = t; return t }(); var S = function () { function t(e, t) { this.name = "UnknownErrorException"; this.message = e; this.details = t } t.prototype = new Error; t.constructor = t; return t }(); var x = function () { function t(e) { this.name = "InvalidPDFException"; this.message = e } t.prototype = new Error; t.constructor = t; return t }(); var T = function () { function t(e) { this.name = "MissingPDFException"; this.message = e } t.prototype = new Error; t.constructor = t; return t }(); var N = function () { function t(e) { this.message = e } t.prototype = new Error; t.prototype.name = "NotImplementedException"; t.constructor = t; return t }(); var C = function () { function t(e, t) { this.begin = e; this.end = t; this.message = "Missing data [" + e + ", " + t + ")" } t.prototype = new Error; t.prototype.name = "MissingDataException"; t.constructor = t; return t }(); var k = function () { function t(e) { this.message = e } t.prototype = new Error; t.prototype.name = "XRefParseException"; t.constructor = t; return t }(); Object.defineProperty(PDFJS, "isLittleEndian", { configurable: true, get: function () { return b(PDFJS, "isLittleEndian", B()) } }); Object.defineProperty(PDFJS, "hasCanvasTypedArrays", { configurable: true, get: function () { return b(PDFJS, "hasCanvasTypedArrays", j()) } }); var F = function () { function t(e, t) { this.buffer = e; this.byteLength = e.length; this.length = t === undefined ? this.byteLength >> 2 : t; i(this.length) } function r(e) { return { get: function () { var t = this.buffer, n = e << 2; return (t[n] | t[n + 1] << 8 | t[n + 2] << 16 | t[n + 3] << 24) >>> 0 }, set: function (t) { var n = this.buffer, r = e << 2; n[r] = t & 255; n[r + 1] = t >> 8 & 255; n[r + 2] = t >> 16 & 255; n[r + 3] = t >>> 24 & 255 } } } function i(e) { while (n < e) { Object.defineProperty(t.prototype, n, r(n)); n++ } } t.prototype = Object.create(null); var n = 0; return t }(); var I = [1, 0, 0, 1, 0, 0]; var q = PDFJS.Util = function () { function t() { } var n = ["rgb(", 0, ",", 0, ",", 0, ")"]; t.makeCssRgb = function (t) { n[1] = t[0]; n[3] = t[1]; n[5] = t[2]; return n.join("") }; t.transform = function (t, n) { return [t[0] * n[0] + t[2] * n[1], t[1] * n[0] + t[3] * n[1], t[0] * n[2] + t[2] * n[3], t[1] * n[2] + t[3] * n[3], t[0] * n[4] + t[2] * n[5] + t[4], t[1] * n[4] + t[3] * n[5] + t[5]] }; t.applyTransform = function (t, n) { var r = t[0] * n[0] + t[1] * n[2] + n[4]; var i = t[0] * n[1] + t[1] * n[3] + n[5]; return [r, i] }; t.applyInverseTransform = function (t, n) { var r = n[0] * n[3] - n[1] * n[2]; var i = (t[0] * n[3] - t[1] * n[2] + n[2] * n[5] - n[4] * n[3]) / r; var s = (-t[0] * n[1] + t[1] * n[0] + n[4] * n[1] - n[5] * n[0]) / r; return [i, s] }; t.getAxialAlignedBoundingBox = function (n, r) { var i = t.applyTransform(n, r); var s = t.applyTransform(n.slice(2, 4), r); var o = t.applyTransform([n[0], n[3]], r); var u = t.applyTransform([n[2], n[1]], r); return [Math.min(i[0], s[0], o[0], u[0]), Math.min(i[1], s[1], o[1], u[1]), Math.max(i[0], s[0], o[0], u[0]), Math.max(i[1], s[1], o[1], u[1])] }; t.inverseTransform = function (t) { var n = t[0] * t[3] - t[1] * t[2]; return [t[3] / n, -t[1] / n, -t[2] / n, t[0] / n, (t[2] * t[5] - t[4] * t[3]) / n, (t[4] * t[1] - t[5] * t[0]) / n] }; t.apply3dTransform = function (t, n) { return [t[0] * n[0] + t[1] * n[1] + t[2] * n[2], t[3] * n[0] + t[4] * n[1] + t[5] * n[2], t[6] * n[0] + t[7] * n[1] + t[8] * n[2]] }; t.singularValueDecompose2dScale = function (t) { var n = [t[0], t[2], t[1], t[3]]; var r = t[0] * n[0] + t[1] * n[2]; var i = t[0] * n[1] + t[1] * n[3]; var s = t[2] * n[0] + t[3] * n[2]; var o = t[2] * n[1] + t[3] * n[3]; var u = (r + o) / 2; var a = Math.sqrt((r + o) * (r + o) - 4 * (r * o - s * i)) / 2; var f = u + a || 1; var l = u - a || 1; return [Math.sqrt(f), Math.sqrt(l)] }; t.normalizeRect = function (t) { var n = t.slice(0); if (t[0] > t[2]) { n[0] = t[2]; n[2] = t[0] } if (t[1] > t[3]) { n[1] = t[3]; n[3] = t[1] } return n }; t.intersect = function (n, r) { function i(e, t) { return e - t } var s = [n[0], n[2], r[0], r[2]].sort(i), o = [n[1], n[3], r[1], r[3]].sort(i), u = []; n = t.normalizeRect(n); r = t.normalizeRect(r); if (s[0] === n[0] && s[1] === r[0] || s[0] === r[0] && s[1] === n[0]) { u[0] = s[1]; u[2] = s[2] } else { return false } if (o[0] === n[1] && o[1] === r[1] || o[0] === r[1] && o[1] === n[1]) { u[1] = o[1]; u[3] = o[2] } else { return false } return u }; t.sign = function (t) { return t < 0 ? -1 : 1 }; t.appendToArray = function (t, n) { Array.prototype.push.apply(t, n) }; t.prependToArray = function (t, n) { Array.prototype.unshift.apply(t, n) }; t.extendObj = function (t, n) { for (var r in n) { t[r] = n[r] } }; t.getInheritableProperty = function (t, n) { while (t && !t.has(n)) { t = t.get("Parent") } if (!t) { return null } return t.get(n) }; t.inherit = function (t, n, r) { t.prototype = Object.create(n.prototype); t.prototype.constructor = t; for (var i in r) { t.prototype[i] = r[i] } }; t.loadScript = function (t, n) { var r = document.createElement("script"); var i = false; r.setAttribute("src", t); if (n) { r.onload = function () { if (!i) { n() } i = true } } document.getElementsByTagName("head")[0].appendChild(r) }; return t }(); var R = PDFJS.PageViewport = function () { function t(e, t, n, r, i, s) { this.viewBox = e; this.scale = t; this.rotation = n; this.offsetX = r; this.offsetY = i; var o = (e[2] + e[0]) / 2; var u = (e[3] + e[1]) / 2; var a, f, l, c; n = n % 360; n = n < 0 ? n + 360 : n; switch (n) { case 180: a = -1; f = 0; l = 0; c = 1; break; case 90: a = 0; f = 1; l = 1; c = 0; break; case 270: a = 0; f = -1; l = -1; c = 0; break; default: a = 1; f = 0; l = 0; c = -1; break } if (s) { l = -l; c = -c } var h, p; var d, v; if (a === 0) { h = Math.abs(u - e[1]) * t + r; p = Math.abs(o - e[0]) * t + i; d = Math.abs(e[3] - e[1]) * t; v = Math.abs(e[2] - e[0]) * t } else { h = Math.abs(o - e[0]) * t + r; p = Math.abs(u - e[1]) * t + i; d = Math.abs(e[2] - e[0]) * t; v = Math.abs(e[3] - e[1]) * t } this.transform = [a * t, f * t, l * t, c * t, h - a * t * o - l * t * u, p - f * t * o - c * t * u]; this.width = d; this.height = v; this.fontScale = t } t.prototype = { clone: function (n) { n = n || {}; var r = "scale" in n ? n.scale : this.scale; var i = "rotation" in n ? n.rotation : this.rotation; return new t(this.viewBox.slice(), r, i, this.offsetX, this.offsetY, n.dontFlip) }, convertToViewportPoint: function (t, n) { return q.applyTransform([t, n], this.transform) }, convertToViewportRectangle: function (t) { var n = q.applyTransform([t[0], t[1]], this.transform); var r = q.applyTransform([t[2], t[3]], this.transform); return [n[0], n[1], r[0], r[1]] }, convertToPdfPoint: function (t, n) { return q.applyInverseTransform([t, n], this.transform) } }; return t }(); var U = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364]; PDFJS.createPromiseCapability = it; (function () { function u(e) { this._status = n; this._handlers = []; try { e.call(this, this._resolve.bind(this), this._reject.bind(this)) } catch (t) { this._reject(t) } } if (t.Promise) { if (typeof t.Promise.all !== "function") { t.Promise.all = function (e) { var n = 0, r = [], i, s; var o = new t.Promise(function (e, t) { i = e; s = t }); e.forEach(function (e, t) { n++; e.then(function (e) { r[t] = e; n--; if (n === 0) { i(r) } }, s) }); if (n === 0) { i(r) } return o } } if (typeof t.Promise.resolve !== "function") { t.Promise.resolve = function (e) { return new t.Promise(function (t) { t(e) }) } } if (typeof t.Promise.reject !== "function") { t.Promise.reject = function (e) { return new t.Promise(function (t, n) { n(e) }) } } if (typeof t.Promise.prototype.catch !== "function") { t.Promise.prototype.catch = function (e) { return t.Promise.prototype.then(undefined, e) } } return } var n = 0; var r = 1; var i = 2; var s = 500; var o = { handlers: [], running: false, unhandledRejections: [], pendingRejectionCheck: false, scheduleHandlers: function (t) { if (t._status == n) { return } this.handlers = this.handlers.concat(t._handlers); t._handlers = []; if (this.running) { return } this.running = true; setTimeout(this.runHandlers.bind(this), 0) }, runHandlers: function () { var t = 1; var n = Date.now() + t; while (this.handlers.length > 0) { var s = this.handlers.shift(); var o = s.thisPromise._status; var u = s.thisPromise._value; try { if (o === r) { if (typeof s.onResolve == "function") { u = s.onResolve(u) } } else if (typeof s.onReject === "function") { u = s.onReject(u); o = r; if (s.thisPromise._unhandledRejection) { this.removeUnhandeledRejection(s.thisPromise) } } } catch (a) { o = i; u = a } s.nextPromise._updateStatus(o, u); if (Date.now() >= n) { break } } if (this.handlers.length > 0) { setTimeout(this.runHandlers.bind(this), 0); return } this.running = false }, addUnhandledRejection: function (t) { this.unhandledRejections.push({ promise: t, time: Date.now() }); this.scheduleRejectionCheck() }, removeUnhandeledRejection: function (t) { t._unhandledRejection = false; for (var n = 0; n < this.unhandledRejections.length; n++) { if (this.unhandledRejections[n].promise === t) { this.unhandledRejections.splice(n); n-- } } }, scheduleRejectionCheck: function () { if (this.pendingRejectionCheck) { return } this.pendingRejectionCheck = true; setTimeout(function () { this.pendingRejectionCheck = false; var t = Date.now(); for (var n = 0; n < this.unhandledRejections.length; n++) { if (t - this.unhandledRejections[n].time > s) { var r = this.unhandledRejections[n].promise._value; var i = "Unhandled rejection: " + r; if (r.stack) { i += "\n" + r.stack } c(i); this.unhandledRejections.splice(n); n-- } } if (this.unhandledRejections.length) { this.scheduleRejectionCheck() } }.bind(this), s) } }; u.all = function (t) { function f(e) { if (s._status === i) { return } a = []; r(e) } var n, r; var s = new u(function (e, t) { n = e; r = t }); var o = t.length; var a = []; if (o === 0) { n(a); return s } for (var l = 0, c = t.length; l < c; ++l) { var h = t[l]; var p = function (e) { return function (t) { if (s._status === i) { return } a[e] = t; o--; if (o === 0) { n(a) } } }(l); if (u.isPromise(h)) { h.then(p, f) } else { p(h) } } return s }; u.isPromise = function (t) { return t && typeof t.then === "function" }; u.resolve = function (t) { return new u(function (e) { e(t) }) }; u.reject = function (t) { return new u(function (e, n) { n(t) }) }; u.prototype = { _status: null, _value: null, _handlers: null, _unhandledRejection: null, _updateStatus: function (t, n) { if (this._status === r || this._status === i) { return } if (t == r && u.isPromise(n)) { n.then(this._updateStatus.bind(this, r), this._updateStatus.bind(this, i)); return } this._status = t; this._value = n; if (t === i && this._handlers.length === 0) { this._unhandledRejection = true; o.addUnhandledRejection(this) } o.scheduleHandlers(this) }, _resolve: function (t) { this._updateStatus(r, t) }, _reject: function (t) { this._updateStatus(i, t) }, then: function (t, n) { var r = new u(function (e, t) { this.resolve = t; this.reject = t }); this._handlers.push({ thisPromise: this, onResolve: t, onReject: n, nextPromise: r }); o.scheduleHandlers(this); return r }, "catch": function (t) { return this.then(undefined, t) } }; t.Promise = u })(); var st = function () { function t(e, t, n) { while (e.length < n) { e += t } return e } function n() { this.started = {}; this.times = []; this.enabled = true } n.prototype = { time: function (t) { if (!this.enabled) { return } if (t in this.started) { c("Timer is already running for " + t) } this.started[t] = Date.now() }, timeEnd: function (t) { if (!this.enabled) { return } if (!(t in this.started)) { c("Timer has not been started for " + t) } this.times.push({ name: t, start: this.started[t], end: Date.now() }); delete this.started[t] }, toString: function () { var n, r; var i = this.times; var s = ""; var o = 0; for (n = 0, r = i.length; n < r; ++n) { var u = i[n]["name"]; if (u.length > o) { o = u.length } } for (n = 0, r = i.length; n < r; ++n) { var a = i[n]; var f = a.end - a.start; s += t(a["name"], " ", o) + " " + f + "ms\n" } return s } }; return n }(); PDFJS.createBlob = function (t, n) { if (typeof Blob !== "undefined") { return new Blob([t], { type: n }) } var r = new MozBlobBuilder; r.append(t); return r.getBlob(n) }; PDFJS.createObjectURL = function () { var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; return function (n, r) { if (!PDFJS.disableCreateObjectURL && typeof URL !== "undefined" && URL.createObjectURL) { var i = PDFJS.createBlob(n, r); return URL.createObjectURL(i) } var s = "data:" + r + ";base64,"; for (var o = 0, u = n.length; o < u; o += 3) { var a = n[o] & 255; var f = n[o + 1] & 255; var l = n[o + 2] & 255; var c = a >> 2, h = (a & 3) << 4 | f >> 4; var p = o + 1 < u ? (f & 15) << 2 | l >> 6 : 64; var d = o + 2 < u ? l & 63 : 64; s += t[c] + t[h] + t[p] + t[d] } return s } }(); ot.prototype = { on: function (t, n, r) { var i = this.actionHandler; if (i[t]) { h('There is already an actionName called "' + t + '"') } i[t] = [n, r] }, send: function (t, n, r) { var i = { action: t, data: n }; this.postMessage(i, r) }, sendWithPromise: function (t, n, r) { var i = this.callbackIndex++; var s = { action: t, data: n, callbackId: i }; var o = it(); this.callbacksCapabilities[i] = o; try { this.postMessage(s, r) } catch (u) { o.reject(u) } return o.promise }, postMessage: function (e, t) { if (t && this.postMessageTransfers) { this.comObj.postMessage(e, t) } else { this.comObj.postMessage(e) } } }; PDFJS.maxImageSize = PDFJS.maxImageSize === undefined ? -1 : PDFJS.maxImageSize; PDFJS.cMapUrl = PDFJS.cMapUrl === undefined ? null : PDFJS.cMapUrl; PDFJS.cMapPacked = PDFJS.cMapPacked === undefined ? false : PDFJS.cMapPacked; PDFJS.disableFontFace = PDFJS.disableFontFace === undefined ? false : PDFJS.disableFontFace; PDFJS.imageResourcesPath = PDFJS.imageResourcesPath === undefined ? "" : PDFJS.imageResourcesPath; PDFJS.disableWorker = PDFJS.disableWorker === undefined ? false : PDFJS.disableWorker; PDFJS.workerSrc = PDFJS.workerSrc === undefined ? null : PDFJS.workerSrc; PDFJS.disableRange = PDFJS.disableRange === undefined ? false : PDFJS.disableRange; PDFJS.disableAutoFetch = PDFJS.disableAutoFetch === undefined ? false : PDFJS.disableAutoFetch; PDFJS.pdfBug = PDFJS.pdfBug === undefined ? false : PDFJS.pdfBug; PDFJS.postMessageTransfers = PDFJS.postMessageTransfers === undefined ? true : PDFJS.postMessageTransfers; PDFJS.disableCreateObjectURL = PDFJS.disableCreateObjectURL === undefined ? false : PDFJS.disableCreateObjectURL; PDFJS.disableWebGL = PDFJS.disableWebGL === undefined ? true : PDFJS.disableWebGL; PDFJS.useOnlyCssZoom = PDFJS.useOnlyCssZoom === undefined ? false : PDFJS.useOnlyCssZoom; PDFJS.verbosity = PDFJS.verbosity === undefined ? PDFJS.VERBOSITY_LEVELS.warnings : PDFJS.verbosity; PDFJS.maxCanvasPixels = PDFJS.maxCanvasPixels === undefined ? 16777216 : PDFJS.maxCanvasPixels; PDFJS.getDocument = function (t, n, r, i) { var s, o, u; if (typeof t === "string") { t = { url: t } } else if (nt(t)) { t = { data: t } } else if (typeof t !== "object") { h("Invalid parameter in getDocument, need either Uint8Array, " + "string or a parameter object") } if (!t.url && !t.data) { h("Invalid parameter array, need either .data or .url") } var a = {}; for (var f in t) { if (f === "url" && typeof window !== "undefined") { a[f] = g(window.location.href, t[f]); continue } a[f] = t[f] } s = it(); o = it(); u = new lt(s, o, n, i); s.promise.then(function () { u.passwordCallback = r; u.fetchDocument(a) }); return o.promise }; var at = function () { function t(e, t) { this.pdfInfo = e; this.transport = t } t.prototype = { get numPages() { return this.pdfInfo.numPages }, get fingerprint() { return this.pdfInfo.fingerprint }, getPage: function (t) { return this.transport.getPage(t) }, getPageIndex: function (t) { return this.transport.getPageIndex(t) }, getDestinations: function () { return this.transport.getDestinations() }, getAttachments: function () { return this.transport.getAttachments() }, getJavaScript: function () { return this.transport.getJavaScript() }, getOutline: function () { return this.transport.getOutline() }, getMetadata: function () { return this.transport.getMetadata() }, getData: function () { return this.transport.getData() }, getDownloadInfo: function () { return this.transport.downloadInfoCapability.promise }, getStats: function () { return this.transport.getStats() }, cleanup: function () { this.transport.startCleanup() }, destroy: function () { this.transport.destroy() } }; return t }(); var ft = function () { function n(e, n, r) { this.pageIndex = e; this.pageInfo = n; this.transport = r; this.stats = new st; this.stats.enabled = !!t.PDFJS.enableStats; this.commonObjs = r.commonObjs; this.objs = new ct; this.cleanupAfterRender = false; this.pendingDestroy = false; this.intentStates = {} } n.prototype = { get pageNumber() { return this.pageIndex + 1 }, get rotate() { return this.pageInfo.rotate }, get ref() { return this.pageInfo.ref }, get view() { return this.pageInfo.view }, getViewport: function (t, n) { if (arguments.length < 2) { n = this.rotate } return new PDFJS.PageViewport(this.view, t, n, 0, 0) }, getAnnotations: function () { if (this.annotationsPromise) { return this.annotationsPromise } var t = this.transport.getAnnotations(this.pageIndex); this.annotationsPromise = t; return t }, render: function (t) { function a(e) { var t = i.renderTasks.indexOf(s); if (t >= 0) { i.renderTasks.splice(t, 1) } if (u.cleanupAfterRender) { u.pendingDestroy = true } u._tryDestroy(); if (e) { s.capability.reject(e) } else { s.capability.resolve() } n.timeEnd("Rendering"); n.timeEnd("Overall") } var n = this.stats; n.time("Overall"); this.pendingDestroy = false; var r = "intent" in t ? t.intent == "print" ? "print" : "display" : "display"; if (!this.intentStates[r]) { this.intentStates[r] = {} } var i = this.intentStates[r]; if (!i.displayReadyCapability) { i.receivingOperatorList = true; i.displayReadyCapability = it(); i.operatorList = { fnArray: [], argsArray: [], lastChunk: false }; this.stats.time("Page Request"); this.transport.messageHandler.send("RenderPageRequest", { pageIndex: this.pageNumber - 1, intent: r }) } var s = new pt(a, t, this.objs, this.commonObjs, i.operatorList, this.pageNumber); if (!i.renderTasks) { i.renderTasks = [] } i.renderTasks.push(s); var o = new ht(s); var u = this; i.displayReadyCapability.promise.then(function (t) { if (u.pendingDestroy) { a(); return } n.time("Rendering"); s.initalizeGraphics(t); s.operatorListChanged() }, function (t) { a(t) }); return o }, getOperatorList: function () { function t() { if (r.operatorList.lastChunk) { r.opListReadCapability.resolve(r.operatorList) } } var n = "oplist"; if (!this.intentStates[n]) { this.intentStates[n] = {} } var r = this.intentStates[n]; if (!r.opListReadCapability) { var i = {}; i.operatorListChanged = t; r.receivingOperatorList = true; r.opListReadCapability = it(); r.renderTasks = []; r.renderTasks.push(i); r.operatorList = { fnArray: [], argsArray: [], lastChunk: false }; this.transport.messageHandler.send("RenderPageRequest", { pageIndex: this.pageIndex, intent: n }) } return r.opListReadCapability.promise }, getTextContent: function () { return this.transport.messageHandler.sendWithPromise("GetTextContent", { pageIndex: this.pageNumber - 1 }) }, destroy: function () { this.pendingDestroy = true; this._tryDestroy() }, _tryDestroy: function () { if (!this.pendingDestroy || Object.keys(this.intentStates).some(function (e) { var t = this.intentStates[e]; return t.renderTasks.length !== 0 || t.receivingOperatorList }, this)) { return } Object.keys(this.intentStates).forEach(function (e) { delete this.intentStates[e] }, this); this.objs.clear(); this.annotationsPromise = null; this.pendingDestroy = false }, _startRenderPage: function (t, n) { var r = this.intentStates[n]; if (r.displayReadyCapability) { r.displayReadyCapability.resolve(t) } }, _renderPageChunk: function (t, n) { var r = this.intentStates[n]; var i, s; for (i = 0, s = t.length; i < s; i++) { r.operatorList.fnArray.push(t.fnArray[i]); r.operatorList.argsArray.push(t.argsArray[i]) } r.operatorList.lastChunk = t.lastChunk; for (i = 0; i < r.renderTasks.length; i++) { r.renderTasks[i].operatorListChanged() } if (t.lastChunk) { r.receivingOperatorList = false; this._tryDestroy() } } }; return n }(); var lt = function () { function n(e, n, r, i) { this.pdfDataRangeTransport = r; this.workerInitializedCapability = e; this.workerReadyCapability = n; this.progressCallback = i; this.commonObjs = new ct; this.pageCache = []; this.pagePromises = []; this.downloadInfoCapability = it(); this.passwordCallback = null; if (!t.PDFJS.disableWorker && typeof Worker !== "undefined") { var s = PDFJS.workerSrc; if (!s) { h("No PDFJS.workerSrc specified") } try { var o = new Worker(s); var u = new ot("main", o); this.messageHandler = u; u.on("test", function (n) { var r = n && n.supportTypedArray; if (r) { this.worker = o; if (!n.supportTransfers) { PDFJS.postMessageTransfers = false } this.setupMessageHandler(u); e.resolve() } else { this.setupFakeWorker() } }.bind(this)); var a = new Uint8Array([PDFJS.postMessageTransfers ? 255 : 0]); try { u.send("test", a, [a.buffer]) } catch (f) { l("Cannot use postMessage transfers"); a[0] = 0; u.send("test", a) } return } catch (c) { l("The worker has been disabled.") } } this.setupFakeWorker() } n.prototype = { destroy: function () { this.pageCache = []; this.pagePromises = []; var t = this; this.messageHandler.sendWithPromise("Terminate", null).then(function () { At.clear(); if (t.worker) { t.worker.terminate() } }) }, setupFakeWorker: function () { t.PDFJS.disableWorker = true; if (!PDFJS.fakeWorkerFilesLoadedCapability) { PDFJS.fakeWorkerFilesLoadedCapability = it(); q.loadScript(PDFJS.workerSrc, function () { PDFJS.fakeWorkerFilesLoadedCapability.resolve() }) } PDFJS.fakeWorkerFilesLoadedCapability.promise.then(function () { c("Setting up fake worker."); var e = { postMessage: function (n) { e.onmessage({ data: n }) }, terminate: function () { } }; var t = new ot("main", e); this.setupMessageHandler(t); PDFJS.WorkerMessageHandler.setup(t); this.workerInitializedCapability.resolve() }.bind(this)) }, setupMessageHandler: function (t) { function n(e) { t.send("UpdatePassword", e) } this.messageHandler = t; var r = this.pdfDataRangeTransport; if (r) { r.addRangeListener(function (e, n) { t.send("OnDataRange", { begin: e, chunk: n }) }); r.addProgressListener(function (e) { t.send("OnDataProgress", { loaded: e }) }); t.on("RequestDataRange", function (t) { r.requestDataRange(t.begin, t.end) }, this) } t.on("GetDoc", function (t) { var n = t.pdfInfo; this.numPages = t.pdfInfo.numPages; var r = new at(n, this); this.pdfDocument = r; this.workerReadyCapability.resolve(r) }, this); t.on("NeedPassword", function (t) { if (this.passwordCallback) { return this.passwordCallback(n, w.NEED_PASSWORD) } this.workerReadyCapability.reject(t.exception.message, t.exception) }, this); t.on("IncorrectPassword", function (t) { if (this.passwordCallback) { return this.passwordCallback(n, w.INCORRECT_PASSWORD) } this.workerReadyCapability.reject(t.exception.message, t.exception) }, this); t.on("InvalidPDF", function (t) { this.workerReadyCapability.reject(t.exception.name, t.exception) }, this); t.on("MissingPDF", function (t) { this.workerReadyCapability.reject(t.exception.message, t.exception) }, this); t.on("UnknownError", function (t) { this.workerReadyCapability.reject(t.exception.message, t.exception) }, this); t.on("DataLoaded", function (t) { this.downloadInfoCapability.resolve(t) }, this); t.on("StartRenderPage", function (t) { var n = this.pageCache[t.pageIndex]; n.stats.timeEnd("Page Request"); n._startRenderPage(t.transparency, t.intent) }, this); t.on("RenderPageChunk", function (t) { var n = this.pageCache[t.pageIndex]; n._renderPageChunk(t.operatorList, t.intent) }, this); t.on("commonobj", function (t) { var n = t[0]; var r = t[1]; if (this.commonObjs.hasData(n)) { return } switch (r) { case "Font": var i = t[2]; var s; if ("error" in i) { var o = i.error; c("Error during font loading: " + o); this.commonObjs.resolve(n, o); break } else { s = new Ot(i) } At.bind([s], function (t) { this.commonObjs.resolve(n, s) }.bind(this)); break; case "FontPath": this.commonObjs.resolve(n, t[2]); break; default: o("Got unknown common object type " + r) } }, this); t.on("obj", function (t) { var n = t[0]; var r = t[1]; var i = t[2]; var s = this.pageCache[r]; var o; if (s.objs.hasData(n)) { return } switch (i) { case "JpegStream": o = t[3]; ut(n, o, s.objs); break; case "Image": o = t[3]; s.objs.resolve(n, o); var u = 8e6; if (o && "data" in o && o.data.length > u) { s.cleanupAfterRender = true } break; default: h("Got unknown object type " + i) } }, this); t.on("DocProgress", function (t) { if (this.progressCallback) { this.progressCallback({ loaded: t.loaded, total: t.total }) } }, this); t.on("DocError", function (t) { this.workerReadyCapability.reject(t) }, this); t.on("PageError", function (t) { var n = this.pageCache[t.pageNum - 1]; var r = n.intentStates[t.intent]; if (r.displayReadyCapability.promise) { r.displayReadyCapability.reject(t.error) } else { h(t.error) } }, this); t.on("JpegDecode", function (e) { var t = e[0]; var n = e[1]; if (n != 3 && n != 1) { return Promise.reject(new Error("Only 3 components or 1 component can be returned")) } return new Promise(function (e, r) { var i = new Image; i.onload = function () { var t = i.width; var r = i.height; var s = t * r; var o = s * 4; var u = new Uint8Array(s * n); var a = yt(t, r); var f = a.getContext("2d"); f.drawImage(i, 0, 0); var l = f.getImageData(0, 0, t, r).data; var c, h; if (n == 3) { for (c = 0, h = 0; c < o; c += 4, h += 3) { u[h] = l[c]; u[h + 1] = l[c + 1]; u[h + 2] = l[c + 2] } } else if (n == 1) { for (c = 0, h = 0; c < o; c += 4, h++) { u[h] = l[c] } } e({ data: u, width: t, height: r }) }; i.onerror = function () { r(new Error("JpegDecode failed to load image")) }; i.src = t }) }) }, fetchDocument: function (t) { t.disableAutoFetch = PDFJS.disableAutoFetch; t.chunkedViewerLoading = !!this.pdfDataRangeTransport; this.messageHandler.send("GetDocRequest", { source: t, disableRange: PDFJS.disableRange, maxImageSize: PDFJS.maxImageSize, cMapUrl: PDFJS.cMapUrl, cMapPacked: PDFJS.cMapPacked, disableFontFace: PDFJS.disableFontFace, disableCreateObjectURL: PDFJS.disableCreateObjectURL, verbosity: PDFJS.verbosity }) }, getData: function () { return this.messageHandler.sendWithPromise("GetData", null) }, getPage: function (t, n) { if (t <= 0 || t > this.numPages || (t | 0) !== t) { return Promise.reject(new Error("Invalid page request")) } var r = t - 1; if (r in this.pagePromises) { return this.pagePromises[r] } var i = this.messageHandler.sendWithPromise("GetPage", { pageIndex: r }).then(function (e) { var t = new ft(r, e, this); this.pageCache[r] = t; return t }.bind(this)); this.pagePromises[r] = i; return i }, getPageIndex: function (t) { return this.messageHandler.sendWithPromise("GetPageIndex", { ref: t }) }, getAnnotations: function (t) { return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: t }) }, getDestinations: function () { return this.messageHandler.sendWithPromise("GetDestinations", null) }, getAttachments: function () { return this.messageHandler.sendWithPromise("GetAttachments", null) }, getJavaScript: function () { return this.messageHandler.sendWithPromise("GetJavaScript", null) }, getOutline: function () { return this.messageHandler.sendWithPromise("GetOutline", null) }, getMetadata: function () { return this.messageHandler.sendWithPromise("GetMetadata", null).then(function (t) { return { info: t[0], metadata: t[1] ? new PDFJS.Metadata(t[1]) : null } }) }, getStats: function () { return this.messageHandler.sendWithPromise("GetStats", null) }, startCleanup: function () { this.messageHandler.sendWithPromise("Cleanup", null).then(function () { for (var t = 0, n = this.pageCache.length; t < n; t++) { var r = this.pageCache[t]; if (r) { r.destroy() } } this.commonObjs.clear(); At.clear() }.bind(this)) } }; return n }(); var ct = function () { function t() { this.objs = {} } t.prototype = { ensureObj: function (t) { if (this.objs[t]) { return this.objs[t] } var n = { capability: it(), data: null, resolved: false }; this.objs[t] = n; return n }, get: function (t, n) { if (n) { this.ensureObj(t).capability.promise.then(n); return null } var r = this.objs[t]; if (!r || !r.resolved) { h("Requesting object that isn't resolved yet " + t) } return r.data }, resolve: function (t, n) { var r = this.ensureObj(t); r.resolved = true; r.data = n; r.capability.resolve(n) }, isResolved: function (t) { var n = this.objs; if (!n[t]) { return false } else { return n[t].resolved } }, hasData: function (t) { return this.isResolved(t) }, getData: function (t) { var n = this.objs; if (!n[t] || !n[t].resolved) { return null } else { return n[t].data } }, clear: function () { this.objs = {} } }; return t }(); var ht = function () { function t(e) { this.internalRenderTask = e; this.promise = this.internalRenderTask.capability.promise } t.prototype = { cancel: function () { this.internalRenderTask.cancel() }, then: function (t, n) { return this.promise.then(t, n) } }; return t }(); var pt = function () { function n(e, t, n, r, i, s) { this.callback = e; this.params = t; this.objs = n; this.commonObjs = r; this.operatorListIdx = null; this.operatorList = i; this.pageNumber = s; this.running = false; this.graphicsReadyCallback = null; this.graphicsReady = false; this.cancelled = false; this.capability = it(); this._continueBound = this._continue.bind(this); this._scheduleNextBound = this._scheduleNext.bind(this); this._nextBound = this._next.bind(this) } n.prototype = { initalizeGraphics: function (n) { if (this.cancelled) { return } if (PDFJS.pdfBug && "StepperManager" in t && t.StepperManager.enabled) { this.stepper = t.StepperManager.create(this.pageNumber - 1); this.stepper.init(this.operatorList); this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint() } var r = this.params; this.gfx = new xt(r.canvasContext, this.commonObjs, this.objs, r.imageLayer); this.gfx.beginDrawing(r.viewport, n); this.operatorListIdx = 0; this.graphicsReady = true; if (this.graphicsReadyCallback) { this.graphicsReadyCallback() } }, cancel: function () { this.running = false; this.cancelled = true; this.callback("cancelled") }, operatorListChanged: function () { if (!this.graphicsReady) { if (!this.graphicsReadyCallback) { this.graphicsReadyCallback = this._continueBound } return } if (this.stepper) { this.stepper.updateOperatorList(this.operatorList) } if (this.running) { return } this._continue() }, _continue: function () { this.running = true; if (this.cancelled) { return } if (this.params.continueCallback) { this.params.continueCallback(this._scheduleNextBound) } else { this._scheduleNext() } }, _scheduleNext: function () { window.requestAnimationFrame(this._nextBound) }, _next: function () { if (this.cancelled) { return } this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper); if (this.operatorListIdx === this.operatorList.argsArray.length) { this.running = false; if (this.operatorList.lastChunk) { this.gfx.endDrawing(); this.callback() } } } }; return n }(); var dt = PDFJS.Metadata = function () { function t(e) { return e.replace(/>\\376\\377([^<]+)/g, function (e, t) { var n = t.replace(/\\([0-3])([0-7])([0-7])/g, function (e, t, n, r) { return String.fromCharCode(t * 64 + n * 8 + r * 1) }); var r = ""; for (var i = 0; i < n.length; i += 2) { var s = n.charCodeAt(i) * 256 + n.charCodeAt(i + 1); r += s >= 32 && s < 127 && s != 60 && s != 62 && s != 38 && false ? String.fromCharCode(s) : "&#x" + (65536 + s).toString(16).substring(1) + ";" } return ">" + r }) } function n(e) { if (typeof e === "string") { e = t(e); var n = new DOMParser; e = n.parseFromString(e, "application/xml") } else if (!(e instanceof Document)) { h("Metadata: Invalid metadata object") } this.metaDocument = e; this.metadata = {}; this.parse() } n.prototype = { parse: function () { var t = this.metaDocument; var n = t.documentElement; if (n.nodeName.toLowerCase() !== "rdf:rdf") { n = n.firstChild; while (n && n.nodeName.toLowerCase() !== "rdf:rdf") { n = n.nextSibling } } var r = n ? n.nodeName.toLowerCase() : null; if (!n || r !== "rdf:rdf" || !n.hasChildNodes()) { return } var i = n.childNodes, s, o, u, a, f, l, c; for (a = 0, l = i.length; a < l; a++) { s = i[a]; if (s.nodeName.toLowerCase() !== "rdf:description") { continue } for (f = 0, c = s.childNodes.length; f < c; f++) { if (s.childNodes[f].nodeName.toLowerCase() !== "#text") { o = s.childNodes[f]; u = o.nodeName.toLowerCase(); this.metadata[u] = o.textContent.trim() } } } }, get: function (t) { return this.metadata[t] || null }, has: function (t) { return typeof this.metadata[t] !== "undefined" } }; return n }(); var vt = 16; var mt = 4096; var gt = true; var wt = function () { var t = {}; return { getCanvas: function (n, r, i, s) { var o; if (n in t) { o = t[n]; o.canvas.width = r; o.canvas.height = i; o.context.setTransform(1, 0, 0, 1, 0, 0) } else { var u = yt(r, i); var a = u.getContext("2d"); if (s) { bt(a) } t[n] = o = { canvas: u, context: a } } return o }, clear: function () { for (var e in t) { var n = t[e]; n.canvas.width = 0; n.canvas.height = 0; delete t[e] } } } }(); var St = function () { function t(e) { this.alphaIsShape = false; this.fontSize = 0; this.fontSizeScale = 1; this.textMatrix = I; this.textMatrixScale = 1; this.fontMatrix = r; this.leading = 0; this.x = 0; this.y = 0; this.lineX = 0; this.lineY = 0; this.charSpacing = 0; this.wordSpacing = 0; this.textHScale = 1; this.textRenderingMode = i.FILL; this.textRise = 0; this.fillColor = "#000000"; this.strokeColor = "#000000"; this.fillAlpha = 1; this.strokeAlpha = 1; this.lineWidth = 1; this.activeSMask = null; this.old = e } t.prototype = { clone: function () { return Object.create(this) }, setCurrentPoint: function (t, n) { this.x = t; this.y = n } }; return t }(); var xt = function () { function o(e, t, n, r) { this.ctx = e; this.current = new St; this.stateStack = []; this.pendingClip = null; this.pendingEOFill = false; this.res = null; this.xobjs = null; this.commonObjs = t; this.objs = n; this.imageLayer = r; this.groupStack = []; this.processingType3 = null; this.baseTransform = null; this.baseTransformStack = []; this.groupLevel = 0; this.smaskStack = []; this.smaskCounter = 0; this.tempSMask = null; if (e) { bt(e) } } function u(e, t) { if (typeof ImageData !== "undefined" && t instanceof ImageData) { e.putImageData(t, 0, 0); return } var n = t.height, r = t.width; var i = 16; var o = n / i; var u = Math.floor(o); var a = Math.ceil(o); var f = n - u * i; var l = e.createImageData(r, i); var c = 0, p; var d = t.data; var v = l.data; var m, g, y, b; if (t.kind === s.GRAYSCALE_1BPP) { var w = d.byteLength; var E = PDFJS.hasCanvasTypedArrays ? new Uint32Array(v.buffer) : new F(v); var S = E.length; var x = r + 7 >> 3; var T = 4294967295; var N = PDFJS.isLittleEndian || !PDFJS.hasCanvasTypedArrays ? 4278190080 : 255; for (m = 0; m < a; m++) { y = m < u ? i : f; p = 0; for (g = 0; g < y; g++) { var C = w - c; var k = 0; var L = C > x ? r : C * 8 - 7; var A = L & ~7; var O = 0; var M = 0; for (; k < A; k += 8) { M = d[c++]; E[p++] = M & 128 ? T : N; E[p++] = M & 64 ? T : N; E[p++] = M & 32 ? T : N; E[p++] = M & 16 ? T : N; E[p++] = M & 8 ? T : N; E[p++] = M & 4 ? T : N; E[p++] = M & 2 ? T : N; E[p++] = M & 1 ? T : N } for (; k < L; k++) { if (O === 0) { M = d[c++]; O = 128 } E[p++] = M & O ? T : N; O >>= 1 } } while (p < S) { E[p++] = 0 } e.putImageData(l, 0, m * i) } } else if (t.kind === s.RGBA_32BPP) { g = 0; b = r * i * 4; for (m = 0; m < u; m++) { v.set(d.subarray(c, c + b)); c += b; e.putImageData(l, 0, g); g += i } if (m < a) { b = r * f * 4; v.set(d.subarray(c, c + b)); e.putImageData(l, 0, g) } } else if (t.kind === s.RGB_24BPP) { y = i; b = r * y; for (m = 0; m < a; m++) { if (m >= u) { y = f; b = r * y } p = 0; for (g = b; g--;) { v[p++] = d[c++]; v[p++] = d[c++]; v[p++] = d[c++]; v[p++] = 255 } e.putImageData(l, 0, m * i) } } else { h("bad image kind: " + t.kind) } } function a(e, t) { var n = t.height, r = t.width; var i = 16; var s = n / i; var o = Math.floor(s); var u = Math.ceil(s); var a = n - o * i; var f = e.createImageData(r, i); var l = 0; var c = t.data; var h = f.data; for (var p = 0; p < u; p++) { var d = p < o ? i : a; var v = 3; for (var m = 0; m < d; m++) { var g = 0; for (var y = 0; y < r; y++) { if (!g) { var b = c[l++]; g = 128 } h[v] = b & g ? 0 : 255; v += 4; g >>= 1 } } e.putImageData(f, 0, p * i) } } function p(e, t) { var n = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"]; for (var r = 0, i = n.length; r < i; r++) { var s = n[r]; if (s in e) { t[s] = e[s] } } if ("setLineDash" in e) { t.setLineDash(e.getLineDash()); t.lineDashOffset = e.lineDashOffset } else if ("mozDash" in e) { t.mozDash = e.mozDash; t.mozDashOffset = e.mozDashOffset } } function v(e, t, n, r) { var i = e.length; for (var s = 3; s < i; s += 4) { var o = e[s]; if (o === 0) { e[s - 3] = t; e[s - 2] = n; e[s - 1] = r } else if (o < 255) { var u = 255 - o; e[s - 3] = e[s - 3] * o + t * u >> 8; e[s - 2] = e[s - 2] * o + n * u >> 8; e[s - 1] = e[s - 1] * o + r * u >> 8 } } } function m(e, t) { var n = e.length; var r = 1 / 255; for (var i = 3; i < n; i += 4) { var s = e[i]; t[i] = t[i] * s * r | 0 } } function g(e, t) { var n = e.length; for (var r = 3; r < n; r += 4) { var i = e[r - 3] * 77 + e[r - 2] * 152 + e[r - 1] * 28 | 0; t[r] = t[r] * i >> 16 } } function y(e, t, n, r, i, s) { var o = !!s; var u = o ? s[0] : 0; var a = o ? s[1] : 0; var f = o ? s[2] : 0; var l; if (i === "Luminosity") { l = g } else { l = m } var c = 65536; var h = Math.min(r, Math.ceil(c / n)); for (var p = 0; p < r; p += h) { var d = Math.min(h, r - p); var y = e.getImageData(0, p, n, d); var b = t.getImageData(0, p, n, d); if (o) { v(y.data, u, a, f) } l(y.data, b.data); e.putImageData(b, 0, p) } } function w(e, t, n) { var r = t.canvas; var i = t.context; e.setTransform(t.scaleX, 0, 0, t.scaleY, t.offsetX, t.offsetY); var s = t.backdrop || null; if (Tt.isEnabled) { var o = Tt.composeSMask(n.canvas, r, { subtype: t.subtype, backdrop: s }); e.setTransform(1, 0, 0, 1, 0, 0); e.drawImage(o, t.offsetX, t.offsetY); return } y(i, n, r.width, r.height, t.subtype, s); e.drawImage(r, 0, 0) } var t = 15; var n = 10; var E = ["butt", "round", "square"]; var S = ["miter", "round", "bevel"]; var x = {}; var T = {}; o.prototype = { beginDrawing: function (t, n) { var r = this.ctx.canvas.width; var i = this.ctx.canvas.height; if (n) { this.ctx.clearRect(0, 0, r, i) } else { this.ctx.mozOpaque = true; this.ctx.save(); this.ctx.fillStyle = "rgb(255, 255, 255)"; this.ctx.fillRect(0, 0, r, i); this.ctx.restore() } var s = t.transform; this.ctx.save(); this.ctx.transform.apply(this.ctx, s); this.baseTransform = this.ctx.mozCurrentTransform.slice(); if (this.imageLayer) { this.imageLayer.beginLayout() } }, executeOperatorList: function (r, i, s, o) { var u = r.argsArray; var a = r.fnArray; var l = i || 0; var c = u.length; if (c === l) { return l } var h = c - l > n && typeof s === "function"; var p = h ? Date.now() + t : 0; var d = 0; var v = this.commonObjs; var m = this.objs; var g; while (true) { if (o !== undefined && l === o.nextBreakPoint) { o.breakIt(l, s); return l } g = a[l]; if (g !== f.dependency) { this[g].apply(this, u[l]) } else { var y = u[l]; for (var b = 0, w = y.length; b < w; b++) { var E = y[b]; var S = E[0] === "g" && E[1] === "_"; var x = S ? v : m; if (!x.isResolved(E)) { x.get(E, s); return l } } } l++; if (l === c) { return l } if (h && ++d > n) { if (Date.now() > p) { s(); return l } d = 0 } } }, endDrawing: function () { this.ctx.restore(); wt.clear(); Tt.clear(); if (this.imageLayer) { this.imageLayer.endLayout() } }, setLineWidth: function (t) { this.current.lineWidth = t; this.ctx.lineWidth = t }, setLineCap: function (t) { this.ctx.lineCap = E[t] }, setLineJoin: function (t) { this.ctx.lineJoin = S[t] }, setMiterLimit: function (t) { this.ctx.miterLimit = t }, setDash: function (t, n) { var r = this.ctx; if ("setLineDash" in r) { r.setLineDash(t); r.lineDashOffset = n } else { r.mozDash = t; r.mozDashOffset = n } }, setRenderingIntent: function (t) { }, setFlatness: function (t) { }, setGState: function (t) { for (var n = 0, r = t.length; n < r; n++) { var i = t[n]; var s = i[0]; var o = i[1]; switch (s) { case "LW": this.setLineWidth(o); break; case "LC": this.setLineCap(o); break; case "LJ": this.setLineJoin(o); break; case "ML": this.setMiterLimit(o); break; case "D": this.setDash(o[0], o[1]); break; case "RI": this.setRenderingIntent(o); break; case "FL": this.setFlatness(o); break; case "Font": this.setFont(o[0], o[1]); break; case "CA": this.current.strokeAlpha = i[1]; break; case "ca": this.current.fillAlpha = i[1]; this.ctx.globalAlpha = i[1]; break; case "BM": if (o && o.name && o.name !== "Normal") { var u = o.name.replace(/([A-Z])/g, function (e) { return "-" + e.toLowerCase() }).substring(1); this.ctx.globalCompositeOperation = u; if (this.ctx.globalCompositeOperation !== u) { c('globalCompositeOperation "' + u + '" is not supported') } } else { this.ctx.globalCompositeOperation = "source-over" } break; case "SMask": if (this.current.activeSMask) { this.endSMaskGroup() } this.current.activeSMask = o ? this.tempSMask : null; if (this.current.activeSMask) { this.beginSMaskGroup() } this.tempSMask = null; break } } }, beginSMaskGroup: function () { var t = this.current.activeSMask; var n = t.canvas.width; var r = t.canvas.height; var i = "smaskGroupAt" + this.groupLevel; var s = wt.getCanvas(i, n, r, true); var o = this.ctx; var u = o.mozCurrentTransform; this.ctx.save(); var a = s.context; a.scale(1 / t.scaleX, 1 / t.scaleY); a.translate(-t.offsetX, -t.offsetY); a.transform.apply(a, u); p(o, a); this.ctx = a; this.setGState([["BM", "Normal"], ["ca", 1], ["CA", 1]]); this.groupStack.push(o); this.groupLevel++ }, endSMaskGroup: function () { var t = this.ctx; this.groupLevel--; this.ctx = this.groupStack.pop(); w(this.ctx, this.current.activeSMask, t); this.ctx.restore() }, save: function () { this.ctx.save(); var t = this.current; this.stateStack.push(t); this.current = t.clone(); this.current.activeSMask = null }, restore: function () { if (this.stateStack.length !== 0) { if (this.current.activeSMask !== null) { this.endSMaskGroup() } this.current = this.stateStack.pop(); this.ctx.restore() } }, transform: function (t, n, r, i, s, o) { this.ctx.transform(t, n, r, i, s, o) }, constructPath: function (t, n) { var r = this.ctx; var i = this.current; var s = i.x, o = i.y; for (var u = 0, a = 0, l = t.length; u < l; u++) { switch (t[u] | 0) { case f.rectangle: s = n[a++]; o = n[a++]; var c = n[a++]; var h = n[a++]; if (c === 0) { c = this.getSinglePixelWidth() } if (h === 0) { h = this.getSinglePixelWidth() } var p = s + c; var d = o + h; this.ctx.moveTo(s, o); this.ctx.lineTo(p, o); this.ctx.lineTo(p, d); this.ctx.lineTo(s, d); this.ctx.lineTo(s, o); this.ctx.closePath(); break; case f.moveTo: s = n[a++]; o = n[a++]; r.moveTo(s, o); break; case f.lineTo: s = n[a++]; o = n[a++]; r.lineTo(s, o); break; case f.curveTo: s = n[a + 4]; o = n[a + 5]; r.bezierCurveTo(n[a], n[a + 1], n[a + 2], n[a + 3], s, o); a += 6; break; case f.curveTo2: r.bezierCurveTo(s, o, n[a], n[a + 1], n[a + 2], n[a + 3]); s = n[a + 2]; o = n[a + 3]; a += 4; break; case f.curveTo3: s = n[a + 2]; o = n[a + 3]; r.bezierCurveTo(n[a], n[a + 1], s, o, s, o); a += 4; break; case f.closePath: r.closePath(); break } } i.setCurrentPoint(s, o) }, closePath: function () { this.ctx.closePath() }, stroke: function (t) { t = typeof t !== "undefined" ? t : true; var n = this.ctx; var r = this.current.strokeColor; if (this.current.lineWidth === 0) { n.lineWidth = this.getSinglePixelWidth() } n.globalAlpha = this.current.strokeAlpha; if (r && r.hasOwnProperty("type") && r.type === "Pattern") { n.save(); n.strokeStyle = r.getPattern(n, this); n.stroke(); n.restore() } else { n.stroke() } if (t) { this.consumePath() } n.globalAlpha = this.current.fillAlpha }, closeStroke: function () { this.closePath(); this.stroke() }, fill: function (t) { t = typeof t !== "undefined" ? t : true; var n = this.ctx; var r = this.current.fillColor; var i = false; if (r && r.hasOwnProperty("type") && r.type === "Pattern") { n.save(); n.fillStyle = r.getPattern(n, this); i = true } if (this.pendingEOFill) { if (n.mozFillRule !== undefined) { n.mozFillRule = "evenodd"; n.fill(); n.mozFillRule = "nonzero" } else { try { n.fill("evenodd") } catch (s) { n.fill() } } this.pendingEOFill = false } else { n.fill() } if (i) { n.restore() } if (t) { this.consumePath() } }, eoFill: function () { this.pendingEOFill = true; this.fill() }, fillStroke: function () { this.fill(false); this.stroke(false); this.consumePath() }, eoFillStroke: function () { this.pendingEOFill = true; this.fillStroke() }, closeFillStroke: function () { this.closePath(); this.fillStroke() }, closeEOFillStroke: function () { this.pendingEOFill = true; this.closePath(); this.fillStroke() }, endPath: function () { this.consumePath() }, clip: function () { this.pendingClip = x }, eoClip: function () { this.pendingClip = T }, beginText: function () { this.current.textMatrix = I; this.current.textMatrixScale = 1; this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0 }, endText: function () { var t = this.pendingTextPaths; var n = this.ctx; if (t === undefined) { n.beginPath(); return } n.save(); n.beginPath(); for (var r = 0; r < t.length; r++) { var i = t[r]; n.setTransform.apply(n, i.transform); n.translate(i.x, i.y); i.addToPath(n, i.fontSize) } n.restore(); n.clip(); n.beginPath(); delete this.pendingTextPaths }, setCharSpacing: function (t) { this.current.charSpacing = t }, setWordSpacing: function (t) { this.current.wordSpacing = t }, setHScale: function (t) { this.current.textHScale = t / 100 }, setLeading: function (t) { this.current.leading = -t }, setFont: function (t, n) { var i = this.commonObjs.get(t); var s = this.current; if (!i) { h("Can't find font for " + t) } s.fontMatrix = i.fontMatrix ? i.fontMatrix : r; if (s.fontMatrix[0] === 0 || s.fontMatrix[3] === 0) { c("Invalid font matrix for font " + t) } if (n < 0) { n = -n; s.fontDirection = -1 } else { s.fontDirection = 1 } this.current.font = i; this.current.fontSize = n; if (i.isType3Font) { return } var o = i.loadedName || "sans-serif"; var u = i.black ? i.bold ? "bolder" : "bold" : i.bold ? "bold" : "normal"; var a = i.italic ? "italic" : "normal"; var f = '"' + o + '", ' + i.fallbackName; var l = n >= vt ? n : vt; this.current.fontSizeScale = l != vt ? 1 : n / vt; var p = a + " " + u + " " + l + "px " + f; this.ctx.font = p }, setTextRenderingMode: function (t) { this.current.textRenderingMode = t }, setTextRise: function (t) { this.current.textRise = t }, moveText: function (t, n) { this.current.x = this.current.lineX += t; this.current.y = this.current.lineY += n }, setLeadingMoveText: function (t, n) { this.setLeading(-n); this.moveText(t, n) }, setTextMatrix: function (t, n, r, i, s, o) { this.current.textMatrix = [t, n, r, i, s, o]; this.current.textMatrixScale = Math.sqrt(t * t + n * n); this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0 }, nextLine: function () { this.moveText(0, this.current.leading) }, paintChar: function (t, n, r) { var s = this.ctx; var o = this.current; var u = o.font; var a = o.textRenderingMode; var f = o.fontSize / o.fontSizeScale; var l = a & i.FILL_STROKE_MASK; var c = !!(a & i.ADD_TO_PATH_FLAG); var h; if (u.disableFontFace || c) { h = u.getPathGenerator(this.commonObjs, t) } if (u.disableFontFace) { s.save(); s.translate(n, r); s.beginPath(); h(s, f); if (l === i.FILL || l === i.FILL_STROKE) { s.fill() } if (l === i.STROKE || l === i.FILL_STROKE) { s.stroke() } s.restore() } else { if (l === i.FILL || l === i.FILL_STROKE) { s.fillText(t, n, r) } if (l === i.STROKE || l === i.FILL_STROKE) { s.strokeText(t, n, r) } } if (c) { var p = this.pendingTextPaths || (this.pendingTextPaths = []); p.push({ transform: s.mozCurrentTransform, x: n, y: r, fontSize: f, addToPath: h }) } }, get isFontSubpixelAAEnabled() { var e = document.createElement("canvas").getContext("2d"); e.scale(1.5, 1); e.fillText("I", 0, 10); var t = e.getImageData(0, 0, 10, 10).data; var n = false; for (var r = 3; r < t.length; r += 4) { if (t[r] > 0 && t[r] < 255) { n = true; break } } return b(this, "isFontSubpixelAAEnabled", n) }, showText: function (t) { var n = this.current; var r = n.font; if (r.isType3Font) { return this.showType3Text(t) } var s = n.fontSize; if (s === 0) { return } var o = this.ctx; var u = n.fontSizeScale; var a = n.charSpacing; var f = n.wordSpacing; var l = n.fontDirection; var c = n.textHScale * l; var h = t.length; var p = r.vertical; var d = r.defaultVMetrics; var v = s * n.fontMatrix[0]; var m = n.textRenderingMode === i.FILL && !r.disableFontFace; o.save(); o.transform.apply(o, n.textMatrix); o.translate(n.x, n.y + n.textRise); if (l > 0) { o.scale(c, -1) } else { o.scale(c, 1) } var g = n.lineWidth; var y = n.textMatrixScale; if (y === 0 || g === 0) { g = this.getSinglePixelWidth() } else { g /= y } if (u != 1) { o.scale(u, u); g /= u } o.lineWidth = g; var b = 0, w; for (w = 0; w < h; ++w) { var E = t[w]; if (E === null) { b += l * f; continue } else if (J(E)) { b += -E * s * .001; continue } var S = false; var x = E.fontChar; var T = E.accent; var N, C, k, L; var A = E.width; if (p) { var O, M, _; O = E.vmetric || d; M = E.vmetric ? O[1] : A * .5; M = -M * v; _ = O[2] * v; A = O ? -O[0] : A; N = M / u; C = (b + _) / u } else { N = b / u; C = 0 } if (r.remeasure && A > 0 && this.isFontSubpixelAAEnabled) { var D = o.measureText(x).width * 1e3 / s * u; var P = A / D; S = true; o.save(); o.scale(P, 1); N /= P } if (m && !T) { o.fillText(x, N, C) } else { this.paintChar(x, N, C); if (T) { k = N + T.offset.x / u; L = C - T.offset.y / u; this.paintChar(T.fontChar, k, L) } } var H = A * v + a * l; b += H; if (S) { o.restore() } } if (p) { n.y -= b * c } else { n.x += b * c } o.restore() }, showType3Text: function (t) { var n = this.ctx; var i = this.current; var s = i.font; var o = i.fontSize; var u = i.fontDirection; var a = i.charSpacing; var f = i.wordSpacing; var l = i.textHScale * u; var c = i.fontMatrix || r; var h = t.length; var p, d, v; if (o === 0) { return } n.save(); n.transform.apply(n, i.textMatrix); n.translate(i.x, i.y); n.scale(l, 1); for (p = 0; p < h; ++p) { d = t[p]; if (d === null) { this.ctx.translate(f, 0); i.x += f * l; continue } else if (J(d)) { var m = -d * .001 * o; this.ctx.translate(m, 0); i.x += m * l; continue } this.processingType3 = d; this.save(); n.scale(o, o); n.transform.apply(n, c); var g = s.charProcOperatorList[d.operatorListId]; this.executeOperatorList(g); this.restore(); var y = q.applyTransform([d.width, 0], c); v = (y[0] * o + a) * u; n.translate(v, 0); i.x += v * l } n.restore(); this.processingType3 = null }, setCharWidth: function (t, n) { }, setCharWidthAndBounds: function (t, n, r, i, s, o) { this.ctx.rect(r, i, s - r, o - i); this.clip(); this.endPath() }, getColorN_Pattern: function (t) { var n; if (t[0] === "TilingPattern") { var r = t[1]; n = new Lt(t, r, this.ctx, this.objs, this.commonObjs, this.baseTransform) } else { n = kt(t) } return n }, setStrokeColorN: function () { this.current.strokeColor = this.getColorN_Pattern(arguments) }, setFillColorN: function () { this.current.fillColor = this.getColorN_Pattern(arguments) }, setStrokeRGBColor: function (t, n, r) { var i = q.makeCssRgb(arguments); this.ctx.strokeStyle = i; this.current.strokeColor = i }, setFillRGBColor: function (t, n, r) { var i = q.makeCssRgb(arguments); this.ctx.fillStyle = i; this.current.fillColor = i }, shadingFill: function (t) { var n = this.ctx; this.save(); var r = kt(t); n.fillStyle = r.getPattern(n, this, true); var i = n.mozCurrentTransformInverse; if (i) { var s = n.canvas; var o = s.width; var u = s.height; var a = q.applyTransform([0, 0], i); var f = q.applyTransform([0, u], i); var l = q.applyTransform([o, 0], i); var c = q.applyTransform([o, u], i); var h = Math.min(a[0], f[0], l[0], c[0]); var p = Math.min(a[1], f[1], l[1], c[1]); var d = Math.max(a[0], f[0], l[0], c[0]); var v = Math.max(a[1], f[1], l[1], c[1]); this.ctx.fillRect(h, p, d - h, v - p) } else { this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10) } this.restore() }, beginInlineImage: function () { h("Should not call beginInlineImage") }, beginImageData: function () { h("Should not call beginImageData") }, paintFormXObjectBegin: function (t, n) { this.save(); this.baseTransformStack.push(this.baseTransform); if (et(t) && 6 === t.length) { this.transform.apply(this, t) } this.baseTransform = this.ctx.mozCurrentTransform; if (et(n) && 4 === n.length) { var r = n[2] - n[0]; var i = n[3] - n[1]; this.ctx.rect(n[0], n[1], r, i); this.clip(); this.endPath() } }, paintFormXObjectEnd: function () { this.restore(); this.baseTransform = this.baseTransformStack.pop() }, beginGroup: function (t) { this.save(); var n = this.ctx; if (!t.isolated) { l("TODO: Support non-isolated groups.") } if (t.knockout) { c("Knockout groups not supported.") } var r = n.mozCurrentTransform; if (t.matrix) { n.transform.apply(n, t.matrix) } d(t.bbox, "Bounding box is required."); var i = q.getAxialAlignedBoundingBox(t.bbox, n.mozCurrentTransform); var s = [0, 0, n.canvas.width, n.canvas.height]; i = q.intersect(i, s) || [0, 0, 0, 0]; var o = Math.floor(i[0]); var u = Math.floor(i[1]); var a = Math.max(Math.ceil(i[2]) - o, 1); var f = Math.max(Math.ceil(i[3]) - u, 1); var h = 1, v = 1; if (a > mt) { h = a / mt; a = mt } if (f > mt) { v = f / mt; f = mt } var m = "groupAt" + this.groupLevel; if (t.smask) { m += "_smask_" + this.smaskCounter++ % 2 } var g = wt.getCanvas(m, a, f, true); var y = g.context; y.scale(1 / h, 1 / v); y.translate(-o, -u); y.transform.apply(y, r); if (t.smask) { this.smaskStack.push({ canvas: g.canvas, context: y, offsetX: o, offsetY: u, scaleX: h, scaleY: v, subtype: t.smask.subtype, backdrop: t.smask.backdrop }) } else { n.setTransform(1, 0, 0, 1, 0, 0); n.translate(o, u); n.scale(h, v) } p(n, y); this.ctx = y; this.setGState([["BM", "Normal"], ["ca", 1], ["CA", 1]]); this.groupStack.push(n); this.groupLevel++ }, endGroup: function (t) { this.groupLevel--; var n = this.ctx; this.ctx = this.groupStack.pop(); if (this.ctx.imageSmoothingEnabled !== undefined) { this.ctx.imageSmoothingEnabled = false } else { this.ctx.mozImageSmoothingEnabled = false } if (t.smask) { this.tempSMask = this.smaskStack.pop() } else { this.ctx.drawImage(n.canvas, 0, 0) } this.restore() }, beginAnnotations: function () { this.save(); this.current = new St }, endAnnotations: function () { this.restore() }, beginAnnotation: function (t, n, r) { this.save(); if (et(t) && 4 === t.length) { var i = t[2] - t[0]; var s = t[3] - t[1]; this.ctx.rect(t[0], t[1], i, s); this.clip(); this.endPath() } this.transform.apply(this, n); this.transform.apply(this, r) }, endAnnotation: function () { this.restore() }, paintJpegXObject: function (t, n, r) { var i = this.objs.get(t); if (!i) { c("Dependent image isn't ready yet"); return } this.save(); var s = this.ctx; s.scale(1 / n, -1 / r); s.drawImage(i, 0, 0, i.width, i.height, 0, -r, n, r); if (this.imageLayer) { var o = s.mozCurrentTransformInverse; var u = this.getCanvasPosition(0, 0); this.imageLayer.appendImage({ objId: t, left: u[0], top: u[1], width: n / o[0], height: r / o[3] }) } this.restore() }, paintImageMaskXObject: function (t) { var n = this.ctx; var r = t.width, i = t.height; var s = this.processingType3; if (gt && s && !("compiled" in s)) { var o = 1e3; if (r <= o && i <= o) { s.compiled = Et({ data: t.data, width: r, height: i }) } else { s.compiled = null } } if (s && s.compiled) { s.compiled(n); return } var u = wt.getCanvas("maskCanvas", r, i); var f = u.context; f.save(); a(f, t); f.globalCompositeOperation = "source-in"; var l = this.current.fillColor; f.fillStyle = l && l.hasOwnProperty("type") && l.type === "Pattern" ? l.getPattern(f, this) : l; f.fillRect(0, 0, r, i); f.restore(); this.paintInlineImageXObject(u.canvas) }, paintImageMaskXObjectRepeat: function (t, n, r, i) { var s = t.width; var o = t.height; var u = this.ctx; var f = wt.getCanvas("maskCanvas", s, o); var l = f.context; l.save(); a(l, t); l.globalCompositeOperation = "source-in"; var c = this.current.fillColor; l.fillStyle = c && c.hasOwnProperty("type") && c.type === "Pattern" ? c.getPattern(l, this) : c; l.fillRect(0, 0, s, o); l.restore(); for (var h = 0, p = i.length; h < p; h += 2) { u.save(); u.transform(n, 0, 0, r, i[h], i[h + 1]); u.scale(1, -1); u.drawImage(f.canvas, 0, 0, s, o, 0, -1, 1, 1); u.restore() } }, paintImageMaskXObjectGroup: function (t) { var n = this.ctx; for (var r = 0, i = t.length; r < i; r++) { var s = t[r]; var o = s.width, u = s.height; var f = wt.getCanvas("maskCanvas", o, u); var l = f.context; l.save(); a(l, s); l.globalCompositeOperation = "source-in"; var c = this.current.fillColor; l.fillStyle = c && c.hasOwnProperty("type") && c.type === "Pattern" ? c.getPattern(l, this) : c; l.fillRect(0, 0, o, u); l.restore(); n.save(); n.transform.apply(n, s.transform); n.scale(1, -1); n.drawImage(f.canvas, 0, 0, o, u, 0, -1, 1, 1); n.restore() } }, paintImageXObject: function (t) { var n = this.objs.get(t); if (!n) { c("Dependent image isn't ready yet"); return } this.paintInlineImageXObject(n) }, paintImageXObjectRepeat: function (t, n, r, i) { var s = this.objs.get(t); if (!s) { c("Dependent image isn't ready yet"); return } var o = s.width; var u = s.height; var a = []; for (var f = 0, l = i.length; f < l; f += 2) { a.push({ transform: [n, 0, 0, r, i[f], i[f + 1]], x: 0, y: 0, w: o, h: u }) } this.paintInlineImageXObjectGroup(s, a) }, paintInlineImageXObject: function (t) { var n = t.width; var r = t.height; var i = this.ctx; this.save(); i.scale(1 / n, -1 / r); var s = i.mozCurrentTransformInverse; var o = s[0], a = s[1]; var f = Math.max(Math.sqrt(o * o + a * a), 1); var l = s[2], c = s[3]; var h = Math.max(Math.sqrt(l * l + c * c), 1); var p, d; if (t instanceof HTMLElement || !t.data) { p = t } else { d = wt.getCanvas("inlineImage", n, r); var v = d.context; u(v, t); p = d.canvas } var m = n, g = r; var y = "prescale1"; while (f > 2 && m > 1 || h > 2 && g > 1) { var b = m, w = g; if (f > 2 && m > 1) { b = Math.ceil(m / 2); f /= m / b } if (h > 2 && g > 1) { w = Math.ceil(g / 2); h /= g / w } d = wt.getCanvas(y, b, w); v = d.context; v.clearRect(0, 0, b, w); v.drawImage(p, 0, 0, m, g, 0, 0, b, w); p = d.canvas; m = b; g = w; y = y === "prescale1" ? "prescale2" : "prescale1" } i.drawImage(p, 0, 0, m, g, 0, -r, n, r); if (this.imageLayer) { var E = this.getCanvasPosition(0, -r); this.imageLayer.appendImage({ imgData: t, left: E[0], top: E[1], width: n / s[0], height: r / s[3] }) } this.restore() }, paintInlineImageXObjectGroup: function (t, n) { var r = this.ctx; var i = t.width; var s = t.height; var o = wt.getCanvas("inlineImage", i, s); var a = o.context; u(a, t); for (var f = 0, l = n.length; f < l; f++) { var c = n[f]; r.save(); r.transform.apply(r, c.transform); r.scale(1, -1); r.drawImage(o.canvas, c.x, c.y, c.w, c.h, 0, -1, 1, 1); if (this.imageLayer) { var h = this.getCanvasPosition(c.x, c.y); this.imageLayer.appendImage({ imgData: t, left: h[0], top: h[1], width: i, height: s }) } r.restore() } }, paintSolidColorImageMask: function () { this.ctx.fillRect(0, 0, 1, 1) }, markPoint: function (t) { }, markPointProps: function (t, n) { }, beginMarkedContent: function (t) { }, beginMarkedContentProps: function (t, n) { }, endMarkedContent: function () { }, beginCompat: function () { }, endCompat: function () { }, consumePath: function () { var t = this.ctx; if (this.pendingClip) { if (this.pendingClip === T) { if (t.mozFillRule !== undefined) { t.mozFillRule = "evenodd"; t.clip(); t.mozFillRule = "nonzero" } else { try { t.clip("evenodd") } catch (n) { t.clip() } } } else { t.clip() } this.pendingClip = null } t.beginPath() }, getSinglePixelWidth: function (t) { var n = this.ctx.mozCurrentTransformInverse; return Math.sqrt(Math.max(n[0] * n[0] + n[1] * n[1], n[2] * n[2] + n[3] * n[3])) }, getCanvasPosition: function (t, n) { var r = this.ctx.mozCurrentTransform; return [r[0] * t + r[2] * n + r[4], r[1] * t + r[3] * n + r[5]] } }; for (var N in f) { o.prototype[f[N]] = o.prototype[N] } return o }(); var Tt = function () { function t(e, t, n) { var r = e.createShader(n); e.shaderSource(r, t); e.compileShader(r); var i = e.getShaderParameter(r, e.COMPILE_STATUS); if (!i) { var s = e.getShaderInfoLog(r); throw new Error("Error during shader compilation: " + s) } return r } function n(e, n) { return t(e, n, e.VERTEX_SHADER) } function r(e, n) { return t(e, n, e.FRAGMENT_SHADER) } function i(e, t) { var n = e.createProgram(); for (var r = 0, i = t.length; r < i; ++r) { e.attachShader(n, t[r]) } e.linkProgram(n); var s = e.getProgramParameter(n, e.LINK_STATUS); if (!s) { var o = e.getProgramInfoLog(n); throw new Error("Error during program linking: " + o) } return n } function s(e, t, n) { e.activeTexture(n); var r = e.createTexture(); e.bindTexture(e.TEXTURE_2D, r); e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE); e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE); e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.NEAREST); e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.NEAREST); e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t); return r } function a() { if (o) { return } u = document.createElement("canvas"); o = u.getContext("webgl", { premultipliedalpha: false }) } function h() { var e, t; a(); e = u; u = null; t = o; o = null; var s = n(t, f); var h = r(t, l); var p = i(t, [s, h]); t.useProgram(p); var d = {}; d.gl = t; d.canvas = e; d.resolutionLocation = t.getUniformLocation(p, "u_resolution"); d.positionLocation = t.getAttribLocation(p, "a_position"); d.backdropLocation = t.getUniformLocation(p, "u_backdrop"); d.subtypeLocation = t.getUniformLocation(p, "u_subtype"); var v = t.getAttribLocation(p, "a_texCoord"); var m = t.getUniformLocation(p, "u_image"); var g = t.getUniformLocation(p, "u_mask"); var y = t.createBuffer(); t.bindBuffer(t.ARRAY_BUFFER, y); t.bufferData(t.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), t.STATIC_DRAW); t.enableVertexAttribArray(v); t.vertexAttribPointer(v, 2, t.FLOAT, false, 0, 0); t.uniform1i(m, 0); t.uniform1i(g, 1); c = d } function p(e, t, n) { var r = e.width, i = e.height; if (!c) { h() } var o = c, u = o.canvas, a = o.gl; u.width = r; u.height = i; a.viewport(0, 0, a.drawingBufferWidth, a.drawingBufferHeight); a.uniform2f(o.resolutionLocation, r, i); if (n.backdrop) { a.uniform4f(o.resolutionLocation, n.backdrop[0], n.backdrop[1], n.backdrop[2], 1) } else { a.uniform4f(o.resolutionLocation, 0, 0, 0, 0) } a.uniform1i(o.subtypeLocation, n.subtype === "Luminosity" ? 1 : 0); var f = s(a, e, a.TEXTURE0); var l = s(a, t, a.TEXTURE1); var p = a.createBuffer(); a.bindBuffer(a.ARRAY_BUFFER, p); a.bufferData(a.ARRAY_BUFFER, new Float32Array([0, 0, r, 0, 0, i, 0, i, r, 0, r, i]), a.STATIC_DRAW); a.enableVertexAttribArray(o.positionLocation); a.vertexAttribPointer(o.positionLocation, 2, a.FLOAT, false, 0, 0); a.clearColor(0, 0, 0, 0); a.enable(a.BLEND); a.blendFunc(a.ONE, a.ONE_MINUS_SRC_ALPHA); a.clear(a.COLOR_BUFFER_BIT); a.drawArrays(a.TRIANGLES, 0, 6); a.flush(); a.deleteTexture(f); a.deleteTexture(l); a.deleteBuffer(p); return u } function g() { var e, t; a(); e = u; u = null; t = o; o = null; var s = n(t, d); var f = r(t, v); var l = i(t, [s, f]); t.useProgram(l); var c = {}; c.gl = t; c.canvas = e; c.resolutionLocation = t.getUniformLocation(l, "u_resolution"); c.scaleLocation = t.getUniformLocation(l, "u_scale"); c.offsetLocation = t.getUniformLocation(l, "u_offset"); c.positionLocation = t.getAttribLocation(l, "a_position"); c.colorLocation = t.getAttribLocation(l, "a_color"); m = c } function y(e, t, n, r, i) { if (!m) { g() } var s = m, o = s.canvas, u = s.gl; o.width = e; o.height = t; u.viewport(0, 0, u.drawingBufferWidth, u.drawingBufferHeight); u.uniform2f(s.resolutionLocation, e, t); var a = 0; var f, l, c; for (f = 0, l = r.length; f < l; f++) { switch (r[f].type) { case "lattice": c = r[f].coords.length / r[f].verticesPerRow | 0; a += (c - 1) * (r[f].verticesPerRow - 1) * 6; break; case "triangles": a += r[f].coords.length; break } } var h = new Float32Array(a * 2); var p = new Uint8Array(a * 3); var d = i.coords, v = i.colors; var y = 0, b = 0; for (f = 0, l = r.length; f < l; f++) { var w = r[f], E = w.coords, S = w.colors; switch (w.type) { case "lattice": var x = w.verticesPerRow; c = E.length / x | 0; for (var T = 1; T < c; T++) { var N = T * x + 1; for (var C = 1; C < x; C++, N++) { h[y] = d[E[N - x - 1]]; h[y + 1] = d[E[N - x - 1] + 1]; h[y + 2] = d[E[N - x]]; h[y + 3] = d[E[N - x] + 1]; h[y + 4] = d[E[N - 1]]; h[y + 5] = d[E[N - 1] + 1]; p[b] = v[S[N - x - 1]]; p[b + 1] = v[S[N - x - 1] + 1]; p[b + 2] = v[S[N - x - 1] + 2]; p[b + 3] = v[S[N - x]]; p[b + 4] = v[S[N - x] + 1]; p[b + 5] = v[S[N - x] + 2]; p[b + 6] = v[S[N - 1]]; p[b + 7] = v[S[N - 1] + 1]; p[b + 8] = v[S[N - 1] + 2]; h[y + 6] = h[y + 2]; h[y + 7] = h[y + 3]; h[y + 8] = h[y + 4]; h[y + 9] = h[y + 5]; h[y + 10] = d[E[N]]; h[y + 11] = d[E[N] + 1]; p[b + 9] = p[b + 3]; p[b + 10] = p[b + 4]; p[b + 11] = p[b + 5]; p[b + 12] = p[b + 6]; p[b + 13] = p[b + 7]; p[b + 14] = p[b + 8]; p[b + 15] = v[S[N]]; p[b + 16] = v[S[N] + 1]; p[b + 17] = v[S[N] + 2]; y += 12; b += 18 } } break; case "triangles": for (var k = 0, L = E.length; k < L; k++) { h[y] = d[E[k]]; h[y + 1] = d[E[k] + 1]; p[b] = v[S[f]]; p[b + 1] = v[S[k] + 1]; p[b + 2] = v[S[k] + 2]; y += 2; b += 3 } break } } if (n) { u.clearColor(n[0] / 255, n[1] / 255, n[2] / 255, 1) } else { u.clearColor(0, 0, 0, 0) } u.clear(u.COLOR_BUFFER_BIT); var A = u.createBuffer(); u.bindBuffer(u.ARRAY_BUFFER, A); u.bufferData(u.ARRAY_BUFFER, h, u.STATIC_DRAW); u.enableVertexAttribArray(s.positionLocation); u.vertexAttribPointer(s.positionLocation, 2, u.FLOAT, false, 0, 0); var O = u.createBuffer(); u.bindBuffer(u.ARRAY_BUFFER, O); u.bufferData(u.ARRAY_BUFFER, p, u.STATIC_DRAW); u.enableVertexAttribArray(s.colorLocation); u.vertexAttribPointer(s.colorLocation, 3, u.UNSIGNED_BYTE, false, 0, 0); u.uniform2f(s.scaleLocation, i.scaleX, i.scaleY); u.uniform2f(s.offsetLocation, i.offsetX, i.offsetY); u.drawArrays(u.TRIANGLES, 0, a); u.flush(); u.deleteBuffer(A); u.deleteBuffer(O); return o } function w() { if (c && c.canvas) { c.canvas.width = 0; c.canvas.height = 0 } if (m && m.canvas) { m.canvas.width = 0; m.canvas.height = 0 } c = null; m = null } var o, u; var f = "  attribute vec2 a_position;                                      attribute vec2 a_texCoord;                                                                                                      uniform vec2 u_resolution;                                                                                                      varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_texCoord = a_texCoord;                                      }                                                             "; var l = "  precision mediump float;                                                                                                        uniform vec4 u_backdrop;                                        uniform int u_subtype;                                          uniform sampler2D u_image;                                      uniform sampler2D u_mask;                                                                                                       varying vec2 v_texCoord;                                                                                                        void main() {                                                     vec4 imageColor = texture2D(u_image, v_texCoord);               vec4 maskColor = texture2D(u_mask, v_texCoord);                 if (u_backdrop.a > 0.0) {                                         maskColor.rgb = maskColor.rgb * maskColor.a +                                   u_backdrop.rgb * (1.0 - maskColor.a);         }                                                               float lum;                                                      if (u_subtype == 0) {                                             lum = maskColor.a;                                            } else {                                                          lum = maskColor.r * 0.3 + maskColor.g * 0.59 +                        maskColor.b * 0.11;                                     }                                                               imageColor.a *= lum;                                            imageColor.rgb *= imageColor.a;                                 gl_FragColor = imageColor;                                    }                                                             "; var c = null; var d = "  attribute vec2 a_position;                                      attribute vec3 a_color;                                                                                                         uniform vec2 u_resolution;                                      uniform vec2 u_scale;                                           uniform vec2 u_offset;                                                                                                          varying vec4 v_color;                                                                                                           void main() {                                                     vec2 position = (a_position + u_offset) * u_scale;              vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;         gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);                                                                              v_color = vec4(a_color / 255.0, 1.0);                         }                                                             "; var v = "  precision mediump float;                                                                                                        varying vec4 v_color;                                                                                                           void main() {                                                     gl_FragColor = v_color;                                       }                                                             "; var m = null; return { get isEnabled() { if (PDFJS.disableWebGL) { return false } var e = false; try { a(); e = !!o } catch (t) { } return b(this, "isEnabled", e) }, composeSMask: p, drawFigures: y, clear: w } }(); var Nt = {}; Nt.RadialAxial = { fromIR: function (t) { var n = t[1]; var r = t[2]; var i = t[3]; var s = t[4]; var o = t[5]; var u = t[6]; return { type: "Pattern", getPattern: function (t) { var a; if (n === "axial") { a = t.createLinearGradient(i[0], i[1], s[0], s[1]) } else if (n === "radial") { a = t.createRadialGradient(i[0], i[1], o, s[0], s[1], u) } for (var f = 0, l = r.length; f < l; ++f) { var c = r[f]; a.addColorStop(c[0], c[1]) } return a } } } }; var Ct = function () { function t(e, t, n, r, i, s, o, u) { var a = t.coords, f = t.colors; var l = e.data, c = e.width * 4; var h; if (a[n + 1] > a[r + 1]) { h = n; n = r; r = h; h = s; s = o; o = h } if (a[r + 1] > a[i + 1]) { h = r; r = i; i = h; h = o; o = u; u = h } if (a[n + 1] > a[r + 1]) { h = n; n = r; r = h; h = s; s = o; o = h } var p = (a[n] + t.offsetX) * t.scaleX; var d = (a[n + 1] + t.offsetY) * t.scaleY; var v = (a[r] + t.offsetX) * t.scaleX; var m = (a[r + 1] + t.offsetY) * t.scaleY; var g = (a[i] + t.offsetX) * t.scaleX; var y = (a[i + 1] + t.offsetY) * t.scaleY; if (d >= y) { return } var b = f[s], w = f[s + 1], E = f[s + 2]; var S = f[o], x = f[o + 1], T = f[o + 2]; var N = f[u], C = f[u + 1], k = f[u + 2]; var L = Math.round(d), A = Math.round(y); var O, M, _, D; var P, H, B, j; var F; for (var I = L; I <= A; I++) { if (I < m) { F = I < d ? 0 : d === m ? 1 : (d - I) / (d - m); O = p - (p - v) * F; M = b - (b - S) * F; _ = w - (w - x) * F; D = E - (E - T) * F } else { F = I > y ? 1 : m === y ? 0 : (m - I) / (m - y); O = v - (v - g) * F; M = S - (S - N) * F; _ = x - (x - C) * F; D = T - (T - k) * F } F = I < d ? 0 : I > y ? 1 : (d - I) / (d - y); P = p - (p - g) * F; H = b - (b - N) * F; B = w - (w - C) * F; j = E - (E - k) * F; var q = Math.round(Math.min(O, P)); var R = Math.round(Math.max(O, P)); var U = c * I + q * 4; for (var z = q; z <= R; z++) { F = (O - z) / (O - P); F = F < 0 ? 0 : F > 1 ? 1 : F; l[U++] = M - (M - H) * F | 0; l[U++] = _ - (_ - B) * F | 0; l[U++] = D - (D - j) * F | 0; l[U++] = 255 } } } function n(e, n, r) { var i = n.coords; var s = n.colors; var o, u; switch (n.type) { case "lattice": var a = n.verticesPerRow; var f = Math.floor(i.length / a) - 1; var l = a - 1; for (o = 0; o < f; o++) { var c = o * a; for (var p = 0; p < l; p++, c++) { t(e, r, i[c], i[c + 1], i[c + a], s[c], s[c + 1], s[c + a]); t(e, r, i[c + a + 1], i[c + 1], i[c + a], s[c + a + 1], s[c + 1], s[c + a]) } } break; case "triangles": for (o = 0, u = i.length; o < u; o += 3) { t(e, r, i[o], i[o + 1], i[o + 2], s[o], s[o + 1], s[o + 2]) } break; default: h("illigal figure"); break } } function r(e, t, r, i, s, o) { var u = 1.1; var a = 3e3; var f = Math.floor(e[0]); var l = Math.floor(e[1]); var c = Math.ceil(e[2]) - f; var h = Math.ceil(e[3]) - l; var p = Math.min(Math.ceil(Math.abs(c * t[0] * u)), a); var d = Math.min(Math.ceil(Math.abs(h * t[1] * u)), a); var v = c / p; var m = h / d; var g = { coords: r, colors: i, offsetX: -f, offsetY: -l, scaleX: 1 / v, scaleY: 1 / m }; var y, b, w, E; if (Tt.isEnabled) { y = Tt.drawFigures(p, d, o, s, g); b = wt.getCanvas("mesh", p, d, false); b.context.drawImage(y, 0, 0); y = b.canvas } else { b = wt.getCanvas("mesh", p, d, false); var S = b.context; var x = S.createImageData(p, d); if (o) { var T = x.data; for (w = 0, E = T.length; w < E; w += 4) { T[w] = o[0]; T[w + 1] = o[1]; T[w + 2] = o[2]; T[w + 3] = 255 } } for (w = 0; w < s.length; w++) { n(x, s[w], g) } S.putImageData(x, 0, 0); y = b.canvas } return { canvas: y, offsetX: f, offsetY: l, scaleX: v, scaleY: m } } return r }(); Nt.Mesh = { fromIR: function (t) { var n = t[2]; var r = t[3]; var i = t[4]; var s = t[5]; var o = t[6]; var u = t[8]; return { type: "Pattern", getPattern: function (t, a, f) { var l; if (f) { l = q.singularValueDecompose2dScale(t.mozCurrentTransform) } else { l = q.singularValueDecompose2dScale(a.baseTransform); if (o) { var c = q.singularValueDecompose2dScale(o); l = [l[0] * c[0], l[1] * c[1]] } } var h = Ct(s, l, n, r, i, f ? null : u); if (!f) { t.setTransform.apply(t, a.baseTransform); if (o) { t.transform.apply(t, o) } } t.translate(h.offsetX, h.offsetY); t.scale(h.scaleX, h.scaleY); return t.createPattern(h.canvas, "no-repeat") } } } }; Nt.Dummy = { fromIR: function () { return { type: "Pattern", getPattern: function () { return "hotpink" } } } }; var Lt = function () { function r(e, t, n, r, i, s) { this.operatorList = e[2]; this.matrix = e[3] || [1, 0, 0, 1, 0, 0]; this.bbox = e[4]; this.xstep = e[5]; this.ystep = e[6]; this.paintType = e[7]; this.tilingType = e[8]; this.color = t; this.objs = r; this.commonObjs = i; this.baseTransform = s; this.type = "Pattern"; this.ctx = n } var t = { COLORED: 1, UNCOLORED: 2 }; var n = 3e3; r.prototype = { createPatternCanvas: function (t) { var r = this.operatorList; var i = this.bbox; var s = this.xstep; var o = this.ystep; var u = this.paintType; var a = this.tilingType; var f = this.color; var c = this.objs; var h = this.commonObjs; l("TilingType: " + a); var p = i[0], d = i[1], v = i[2], m = i[3]; var g = [p, d]; var y = [p + s, d + o]; var b = y[0] - g[0]; var w = y[1] - g[1]; var E = q.singularValueDecompose2dScale(this.matrix); var S = q.singularValueDecompose2dScale(this.baseTransform); var x = [E[0] * S[0], E[1] * S[1]]; b = Math.min(Math.ceil(Math.abs(b * x[0])), n); w = Math.min(Math.ceil(Math.abs(w * x[1])), n); var T = wt.getCanvas("pattern", b, w, true); var N = T.context; var C = new xt(N, h, c); C.groupLevel = t.groupLevel; this.setFillAndStrokeStyleToContext(N, u, f); this.setScale(b, w, s, o); this.transformToScale(C); var k = [1, 0, 0, 1, -g[0], -g[1]]; C.transform.apply(C, k); this.clipBbox(C, i, p, d, v, m); C.executeOperatorList(r); return T.canvas }, setScale: function (t, n, r, i) { this.scale = [t / r, n / i] }, transformToScale: function (t) { var n = this.scale; var r = [n[0], 0, 0, n[1], 0, 0]; t.transform.apply(t, r) }, scaleToContext: function () { var t = this.scale; this.ctx.scale(1 / t[0], 1 / t[1]) }, clipBbox: function (t, n, r, i, s, o) { if (n && et(n) && 4 == n.length) { var u = s - r; var a = o - i; t.ctx.rect(r, i, u, a); t.clip(); t.endPath() } }, setFillAndStrokeStyleToContext: function (n, r, i) { switch (r) { case t.COLORED: var s = this.ctx; n.fillStyle = s.fillStyle; n.strokeStyle = s.strokeStyle; break; case t.UNCOLORED: var o = q.makeCssRgb(i); n.fillStyle = o; n.strokeStyle = o; break; default: h("Unsupported paint type: " + r) } }, getPattern: function (t, n) { var r = this.createPatternCanvas(n); t = this.ctx; t.setTransform.apply(t, this.baseTransform); t.transform.apply(t, this.matrix); this.scaleToContext(); return t.createPattern(r, "repeat") } }; return r }(); PDFJS.disableFontFace = false; var At = { insertRule: function (t) { var n = document.getElementById("PDFJS_FONT_STYLE_TAG"); if (!n) { n = document.createElement("style"); n.id = "PDFJS_FONT_STYLE_TAG"; document.documentElement.getElementsByTagName("head")[0].appendChild(n) } var r = n.sheet; r.insertRule(t, r.cssRules.length) }, clear: function () { var t = document.getElementById("PDFJS_FONT_STYLE_TAG"); if (t) { t.parentNode.removeChild(t) } }, get loadTestFont() { return b(this, "loadTestFont", atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQ" + "AABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwA" + "AAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbm" + "FtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAA" + "AADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6A" + "ABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAA" + "MQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAA" + "AAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAA" + "AAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQ" + "AAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMA" + "AQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAA" + "EAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAA" + "AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAA" + "AAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgc" + "A/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWF" + "hYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQA" + "AAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAg" + "ABAAAAAAAAAAAD6AAAAAAAAA==")) }, loadTestFontId: 0, loadingContext: { requests: [], nextRequestId: 0 }, isSyncFontLoadingSupported: function () { if (n) { return false } var t = window.navigator.userAgent; var r = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(t); if (r && r[1] >= 14) { return true } return false }(), bind: function (t, r) { d(!n, "bind() shall be called from main thread"); var i = [], s = []; for (var o = 0, u = t.length; o < u; o++) { var a = t[o]; if (a.attached || a.loading === false) { continue } a.attached = true; var f = a.bindDOM(); if (f) { i.push(f); s.push(a) } } var l = At.queueLoadingCallback(r); if (i.length > 0 && !this.isSyncFontLoadingSupported) { At.prepareFontLoadEvent(i, s, l) } else { l.complete() } }, queueLoadingCallback: function (t) { function n() { d(!s.end, "completeRequest() cannot be called twice"); s.end = Date.now(); while (r.requests.length > 0 && r.requests[0].end) { var e = r.requests.shift(); setTimeout(e.callback, 0) } } var r = At.loadingContext; var i = "pdfjs-font-loading-" + r.nextRequestId++; var s = { id: i, complete: n, callback: t, started: Date.now() }; r.requests.push(s); return s }, prepareFontLoadEvent: function (t, n, r) { function i(e, t) { return e.charCodeAt(t) << 24 | e.charCodeAt(t + 1) << 16 | e.charCodeAt(t + 2) << 8 | e.charCodeAt(t + 3) & 255 } function s(e, t, n, r) { var i = e.substr(0, t); var s = e.substr(t + n); return i + r + s } function h(e, t) { l++; if (l > 30) { c("Load test font never loaded."); t(); return } f.font = "30px " + e; f.fillText(".", 0, 20); var n = f.getImageData(0, 0, 1, 1); if (n.data[3] > 0) { t(); return } setTimeout(h.bind(null, e, t)) } var o, u; var a = document.createElement("canvas"); a.width = 1; a.height = 1; var f = a.getContext("2d"); var l = 0; var p = "lt" + Date.now() + this.loadTestFontId++; var d = this.loadTestFont; var v = 976; d = s(d, v, p.length, p); var m = 16; var g = 1482184792; var y = i(d, m); for (o = 0, u = p.length - 3; o < u; o += 4) { y = y - g + i(p, o) | 0 } if (o < p.length) { y = y - g + i(p + "XXX", o) | 0 } d = s(d, m, 4, M(y)); var b = "url(data:font/opentype;base64," + btoa(d) + ");"; var w = '@font-face { font-family:"' + p + '";src:' + b + "}"; At.insertRule(w); var E = []; for (o = 0, u = n.length; o < u; o++) { E.push(n[o].loadedName) } E.push(p); var S = document.createElement("div"); S.setAttribute("style", "visibility: hidden;" + "width: 10px; height: 10px;" + "position: absolute; top: 0px; left: 0px;"); for (o = 0, u = E.length; o < u; ++o) { var x = document.createElement("span"); x.textContent = "Hi"; x.style.fontFamily = E[o]; S.appendChild(x) } document.body.appendChild(S); h(p, function () { document.body.removeChild(S); r.complete() }) } }; var Ot = function () { function n(e, t, n) { this.compiledGlyphs = {}; if (arguments.length === 1) { var r = arguments[0]; for (var i in r) { this[i] = r[i] } return } } n.prototype = { bindDOM: function () { if (!this.data) { return null } if (PDFJS.disableFontFace) { this.disableFontFace = true; return null } var n = L(new Uint8Array(this.data)); var r = this.loadedName; var i = "url(data:" + this.mimetype + ";base64," + window.btoa(n) + ");"; var s = '@font-face { font-family:"' + r + '";src:' + i + "}"; At.insertRule(s); if (PDFJS.pdfBug && "FontInspector" in t && t["FontInspector"].enabled) { t["FontInspector"].fontAdded(this, i) } return s }, getPathGenerator: function (e, t) { if (!(t in this.compiledGlyphs)) { var n = e.get(this.loadedName + "_path_" + t); this.compiledGlyphs[t] = new Function("c", "size", n) } return this.compiledGlyphs[t] } }; return n }(); var Mt = 4; var _t = 10; var Dt = function () { function t(e, t, n) { var r = e.style; r.fontSize = t.fontSize + "px"; r.direction = t.fontDirection < 0 ? "rtl" : "ltr"; if (!n) { return } r.fontWeight = n.black ? n.bold ? "bolder" : "bold" : n.bold ? "bold" : "normal"; r.fontStyle = n.italic ? "italic" : "normal"; var i = n.loadedName; var s = i ? '"' + i + '", ' : ""; var o = n.fallbackName || "Helvetica, sans-serif"; r.fontFamily = s + o } function n(e, t, n) { var r = n || 0; var i = document.createElement(e); i.style.borderWidth = r + "px"; var s = t[2] - t[0] - 2 * r; var o = t[3] - t[1] - 2 * r; i.style.width = s + "px"; i.style.height = o + "px"; return i } function r(e) { var t = n("section", e.rect, e.borderWidth); t.style.backgroundColor = e.color; var r = e.color; var i = []; for (var s = 0; s < 3; ++s) { i[s] = Math.round(r[s] * 255) } e.colorCssRgb = q.makeCssRgb(i); var o = document.createElement("div"); o.className = "annotationHighlight"; o.style.left = o.style.top = -Mt + "px"; o.style.right = o.style.bottom = -Mt + "px"; o.setAttribute("hidden", true); e.highlightElement = o; t.appendChild(e.highlightElement); return t } function i(e, r) { var i = n("div", e.rect, 0); i.style.display = "table"; var s = document.createElement("div"); s.textContent = e.fieldValue; var o = e.textAlignment; s.style.textAlign = ["left", "center", "right"][o]; s.style.verticalAlign = "middle"; s.style.display = "table-cell"; var u = e.fontRefName ? r.getData(e.fontRefName) : null; t(s, e, u); i.appendChild(s); return i } function s(e, t) { var n = e.rect; if (n[3] - n[1] < _t) { n[3] = n[1] + _t } if (n[2] - n[0] < _t) { n[2] = n[0] + (n[3] - n[1]) } var i = r(e); i.className = "annotText"; var s = document.createElement("img"); s.style.height = i.style.height; s.style.width = i.style.width; var o = e.name; s.src = PDFJS.imageResourcesPath + "annotation-" + o.toLowerCase() + ".svg"; s.alt = "[{{type}} Annotation]"; s.dataset.l10nId = "text_annotation_type"; s.dataset.l10nArgs = JSON.stringify({ type: o }); var u = document.createElement("div"); u.className = "annotTextContentWrapper"; u.style.left = Math.floor(n[2] - n[0] + 5) + "px"; u.style.top = "-10px"; var a = document.createElement("div"); a.className = "annotTextContent"; a.setAttribute("hidden", true); var f, l; if (e.hasBgColor) { var c = e.color; var h = []; for (f = 0; f < 3; ++f) { var p = Math.round(c[f] * 255); h[f] = Math.round((255 - p) * .7) + p } a.style.backgroundColor = q.makeCssRgb(h) } var d = document.createElement("h1"); var v = document.createElement("p"); d.textContent = e.title; if (!e.content && !e.title) { a.setAttribute("hidden", true) } else { var m = document.createElement("span"); var g = e.content.split(/(?:\r\n?|\n)/); for (f = 0, l = g.length; f < l; ++f) { var y = g[f]; m.appendChild(document.createTextNode(y)); if (f < l - 1) { m.appendChild(document.createElement("br")) } } v.appendChild(m); var b = false; var w = function (t) { if (t) { b = true } if (a.hasAttribute("hidden")) { i.style.zIndex += 1; a.removeAttribute("hidden") } }; var E = function (t) { if (t) { b = false } if (!a.hasAttribute("hidden") && !b) { i.style.zIndex -= 1; a.setAttribute("hidden", true) } }; var S = function () { if (b) { E(true) } else { w(true) } }; s.addEventListener("click", function () { S() }, false); s.addEventListener("mouseover", function () { w() }, false); s.addEventListener("mouseout", function () { E() }, false); a.addEventListener("click", function () { E(true) }, false) } a.appendChild(d); a.appendChild(v); u.appendChild(a); i.appendChild(s); i.appendChild(u); return i } function u(e, t) { var n = r(e); n.className = "annotLink"; n.style.borderColor = e.colorCssRgb; n.style.borderStyle = "solid"; var i = document.createElement("a"); i.href = i.title = e.url || ""; n.appendChild(i); return n } function a(e, t) { switch (e.annotationType) { case o.WIDGET: return i(e, t); case o.TEXT: return s(e, t); case o.LINK: return u(e, t); default: throw new Error("Unsupported annotationType: " + e.annotationType) } } return { getHtmlElement: a } }(); PDFJS.AnnotationUtils = Dt }).call(typeof window === "undefined" ? this : window); if (!PDFJS.workerSrc && typeof document !== "undefined") { PDFJS.workerSrc = function () { "use strict"; var e = document.body || document.getElementsByTagName("head")[0]; var t = e.lastChild.src; return t && t.replace(/\.js$/i, ".worker.js") }() }